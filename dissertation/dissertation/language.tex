\chapter{Reactive Component Language\label{language}}

\begin{quote}
In theory, there is no difference between theory and practice. \linebreak
But, in practice, there is.  \emph{Anonymous}
\end{quote}

In this chapter, we present a programming language for reactive components.
We state the motivation for the language, our assumptions for tractability, and the features that guided our design.
We then show how reactive components are expressed in the language and we conclude with illustrative examples.

\section{Challenges}
An implementation of the reactive component model presented in Chapter~\ref{model} is necessary for at least two reasons.
First and foremost, an implementation tests the practicality of the model.
The act of implementing the model can help to evaluate whether the assumptions upon which the model is founded can be realized using existing techniques.
Conversely, an implementation can suggest restrictions to the model that are necessary to produce an effective implementation.
An example of this was seen in Section~\ref{propcomp} where a component instance was used as a proxy for its state variables, for the purpose of determining which variables were involved in a transaction.
Implementation forces one to supply and consider details that can either qualify or disqualify a model as a practical engineering tool.
This is consistent with the emerging attitude in systems research that all new ideas and techniques must be accompanied by relevant tools and evaluations to show their feasibility~\cite{Krishnamurthi:2015:RSC:2739250.2658987}.

Second, an implementation is necessary to demonstrate that the model can be applied successfully to real-world design and implementation problems.
That is, given a platform for reactive components, we can design, construct, and evaluate systems based on the reactive component paradigm.
Furthermore, we can evaluate critically the design and implementation processes that the model and platform encourage.
By comparing implementations of similar systems in different models, we also can gain insight into the strengths and weaknesses of each model.
These ideas will be explored further in Chapter~\ref{implementation}.

\section{Constraints}

Our implementation of the reactive component model is shaped by a number of practical concerns.
First, the implementation must enforce the semantics of the model to avoid subtle errors caused by reasoning about a system using one set of semantics and implementing it using another set of semantics.
Second, the implementation must permit the use of linked data structures as they are fundamental to the efficient implementation of many algorithms.
Third, the implementation must support reference and move semantics for efficient communication.

\paragraph{Strict enforcement of the reactive component model.}
An implementation should provide the checks necessary to enforce the semantics of reactive components.
The checks of interest are 1) the separation of the immutable and mutable phase (Section~\ref{execution}), 2) the binding state of pull ports (Section~\ref{decomposition}), and 3) the detection of non-deterministic state transitions arising from composition (Section~\ref{determinism}).
Not performing these checks is unacceptable due to the subtlety associated with developing correct reactive programs:  the semantics of reactive components would be enforced only through convention which is easily violated.
Similarly, placing the burden on developers is unacceptable due to the amount of detail that must be considered.
Thus, the implementation must enforce the semantics of reactive components through adequate checking.

\paragraph{Support for reference semantics and linked data structures.}
Formal models for reactive systems typically use \emph{logic friendly} data-types, i.e., those that do not introduce aliasing, to make proofs easier.
However, reference semantics and the linked data structures they make possible are a critical part of modern software engineering.
As two of our objectives are practicality and utility, our language for reactive components must support reference semantics and linked data structures.
The potential hazard created by reference semantics is that the state of one component becomes accessible in another component.
This means that the state of a component may not be solely under the control of the transitions for that component.
Consequently, the properties associated with that component could be violated by the other components manipulating that state.
Furthermore, an implementation that chooses to execute seemingly independent transactions concurrently may cause data corruption as two transactions may manipulate the same state in an uncoordinated fashion.
Thus, our implementation of reactive components must take special care to preserve isolation of state among reactive components when supporting references and linked data structures.

\paragraph{Efficient inter-component communication.}
Linked data structures also create an opportunity for efficient communication between components.
There are three modes by which a component (sender) can share information with another component (receiver) as they interact through push ports and pull ports.
First, the sender may use \emph{value semantics} where it provides a complete copy of the value to be communicated.
This approach is reasonable for values like numbers and small records.
Second, a sender may use \emph{reference semantics} where it provides a pointer (reference) to the data to be communicated.
This approach is reasonable when the sender offers up a large data structure.
The receiver is responsible for copying any data that needs to be retained.
When using such reference semantics, receivers may read and copy the data structure represented by the pointer but may not alter or remember the original data structure in any way.
Third, a sender may use \emph{move semantics} where it provides a pointer to a data structure that the receiver may adopt as its own.
In this case, the sender promises to ``forget'' the data structure as the receiver is the new owner of the data structure.
Move semantics are appropriate when the size of the data to be communicated is large, there is a single receiver, and the sender does not need to retain the data.
These conditions may arise in situations like network stacks and pipelines.
Without move semantics, the practicality of the reactive component model is greatly diminished.

\section{Approach}

Our approach to implementing the reactive component model defined in Chapter~\ref{model} is to define a programming language that facilitates the direct expression of reactive components.
Language support for the model is beneficial because it closes the semantic gap between reasoning and implementation.
The importance of language support can be seen in techniques like structured programming~\cite{dahl1972structured} and object-oriented programming~\cite{booch1982object}.
While these techniques can be applied in virtually any setting, their lasting utility is derived from their implementation in a variety of programming languages.
Providing language support for reactive components raises the level of abstraction and allows reasoning about a system consisting of them directly from its specification instead of reasoning in one set of semantics while implementing in another which can be tedious and error-prone.

Language support allows developers to rely on the consistent application of the semantics of the model through strict enforcement.
Crafting a new language specifically for reactive components creates an opportunity to introduce syntax and semantics that allow a compiler or interpreter to distinguish programs that conform to the semantics of reactive components from those that \emph{potentially} may not.
To illustrate, consider the problem of ensuring that the state of a component does not change during the immutable phase of a transition.
We observe that an action/reaction is similar to a method.
Based on this observation, checking the immutability of a component in the immutable phase should be similar to checking for \verb+const+ correctness in C++.
In C++, the \verb+const+ correctness check is performed early in the compilation process when the program is represented as an abstract syntax tree (AST) with full semantic information, as opposed to late in the process where the program is represented by machine instructions with very limited semantic information.
From this, we observe that such checking is supported by 1) adding features to the language which provide the necessary semantic information and 2) performing the checks early in the translation process.
An existing language might not provide enough detail to enable the necessary checks or to achieve them efficiently.
Along these same lines, an implementation may have to make conservative assumptions to enforce the semantics of reactive components.
As was seen in Section~\ref{propcomp}, allowing a component instance to serve as a proxy for all of its state variables allows the check for non-deterministic state transitions to be implemented using known techniques.

\section{Preliminaries}

\paragraph{Go.}
Rather than start from scratch, we adopt Go~\cite{go} as the foundation for a programming language for reactive components.
Actions, reactions, getters, initializers, and bindings are expressed using Go's syntax for methods.
Component types are constructed using the syntax of structs.
Push ports and pull ports are fields of a component.
To enforce the immutable phase and facilitate checks for reference semantics, we introduced syntax that prevents the abuse of pointers.
Activations in the model correspond to activate statements which activate push ports and contain the mutable phase of a state transitions.
Move semantics are realized through a new \emph{tranferrable heap} type and associated operations.

Go is an imperative programming language with a straightforward type system and expressions and statements resembling C.
Go supports methods but places no emphasis on an inheritance hierarchy.
In the same vein, Go does not have constructors, destructors, function overloading, or operator overloading.
This combination, makes Go an attractive foundation for a language for reactive components since it is tractable in implementation and approachable by a general audience.
We defer to Go's syntax and semantics for our definitions of types, declarations, statements, and expressions.
We will not discuss the syntax and semantics of Go except when they interact with the semantics of reactive components.
Our implementation of Go's types, declarations, statements, and expressions is intentionally only as broad as is needed to demonstrate the contributions of this dissertation.

\paragraph{Static system assumption.}
To make implementation more tractable, we will assume that the systems to be implemented have a static topology, meaning that all reactive components are statically allocated.
Both finite state and infinite state (subject to system resource limits) reactive components are permitted, but both the number and configurations of reactive components in a system are fixed.
This is roughly equivalent to systems that assume a fixed number of actors or threads.
These assumptions are common in embedded and real-time systems due to the combination of limited resources and a need for predictability.
These assumptions also are common in many other less constrained environments, as the number of threads is often fixed by the design, e.g., only a fixed number of concurrent activities is needed, or the number of threads is limited by the number of available physical cores.
Thus, even with the static system assumption, an implementation of the model is still applicable to many systems of interest.
We leave the implementation of extensions that facilitate the dynamic creation and binding of reactive components for future work.

\begin{figure}
\centering
\resizebox{\textwidth}{!}{%
\begin{tikzpicture}
[
  >=stealth',
  punkt/.style={
    rectangle,
    rounded corners,
    draw=black, very thick,
    text width=6.5em,
    minimum height=2em,
    text centered
  },
  pil/.style={
    ->,
    thick,
    %%shorten <=2pt,
    %%shorten >=2pt,
  }
]

\node[punkt] (constants) at (0,0) {Constant Segment};

%% stacks
\node[punkt,right=2cm of constants] (stack1) {Stack 1};
\node[punkt,below=4cm of stack1] (stack2) {Stack 2};
\node[below=1cm of stack2] (stackdots) {...};
\node[punkt,below=1cm of stackdots] (stacks) {Stack S};

%% components
\node[punkt,right=1cm of stack1] (component1) {Component 1};
\node[punkt,below=4cm of component1] (component2) {Component 2};
\node[below=1cm of component2] (componentdots) {...};
\node[punkt,below=1cm of componentdots] (componentc) {Component C};

%% heaps
\node[punkt, text width=4.5em,below=1cm of component1] (heap1) {Heap 1};
\node[punkt] (heap2) at ($(component1) + (6,3)$) {Transferable Heap 1};
\node[punkt, below=1cm of heap2] (heap3) {Transferable Heap 2};
\node[below=1cm of heap3] (heapdots) {...};
\node[punkt, below=1cm of heapdots] (heaph) {Transferable Heap H};

\node[punkt] (heap21) at ($(heaph) + (-2,-2)$) {Transferable Heap H.1};
\node[punkt] (heap22) at ($(heaph) + (2,-2)$) {Transferable Heap H.2};

\draw[pil,->] (stack1) -- (component1);
\draw[pil,->] (stack1) -- (component2.north west);
\draw[pil,->] (stack1) -- (heap1.north west);
\draw[pil,->] (stack1) -- (heap2.west);

\draw[pil,<->] (component1.south) -- (heap1.north);
\draw[pil,->] (component1.east) -- (heap2.west);
\draw[pil,->] (component1.east) -- (heap3.west);
\draw[pil,->] (heap1.east) -- (heaph.west);

\draw[pil,->] (heaph) -- (heap21.north);
\draw[pil,->] (heaph) -- (heap22.north);

\path[pil] (stack1.west) edge [loop above, out=-135, in=135, min distance=1.5cm] (stack1.west);
\path[pil] (stack2.west) edge [loop above, out=-135, in=135, min distance=1.5cm] (stack2.west);
\path[pil] (stacks.west) edge [loop above, out=-135, in=135, min distance=1.5cm] (stacks.west);

\path[pil] (component1.north) edge [loop above, out=135, in=45, min distance=1.5cm] (component1.north);
\path[pil] (component2.north) edge [loop above, out=135, in=45, min distance=1.5cm] (component2.north);
\path[pil] (componentc.north) edge [loop above, out=135, in=45, min distance=1.5cm] (componentc.north);

\path[pil] (heap1.south) edge [loop above, out=-45, in=-135, min distance=1.5cm] (heap1.south);
\path[pil] (heap2.east) edge [loop above, out=45, in=-45, min distance=1.5cm] (heap2.east);
\path[pil] (heap3.east) edge [loop above, out=45, in=-45, min distance=1.5cm] (heap3.east);
\path[pil] (heaph.east) edge [loop above, out=45, in=-45, min distance=1.5cm] (heaph.east);

\path[pil] (heap21.east) edge [loop above, out=45, in=-45, min distance=1.5cm] (heap21.east);
\path[pil] (heap22.east) edge [loop above, out=45, in=-45, min distance=1.5cm] (heap22.east);

\end{tikzpicture}
}%
\caption{Memory model.
An edge from one segment to another indicates that a pointer in one segment (source) may refer to a location in another segment (target).
Any pointer may refer to a location in the constant segment (these edges are not shown).}
\label{memory_model}
\end{figure}

\paragraph{Memory model.}
Figure~\ref{memory_model} shows the memory model for the reactive component programming language.
A pointer may refer to a location in the constant segment, a stack segment, a component segment, a heap segment, or a transferable heap segment.
The edges in the figure indicate that a pointer in one segment may refer to a location in another segment.
As implied by the name, the constant segment is used to store constants like string literals.
A pointer in any segment may refer to the constant segment.
These edges are not shown shown in the figure.

Function parameters and local variables are allocated on a call stack as they are in C or C++.
Multiple stacks may be present if multiple transactions are executed concurrently.
As indicated by the figure, a pointer in a stack segment may refer to a component segment, a heap segment, a transferable heap segment, or the constant segment.
A pointer referring to a location on a call stack becomes invalid after the corresponding transaction is complete and the call stack is cleared.
Consequently, it is not safe to allow static or dynamic component state to refer to a location in a stack as it may create a dangling pointer.
Escape analysis~\cite{Park:1992:EAL:143095.143125} can be used to determine if an object should be dynamically allocated to avoid this problem.
It is permissible to allow a pointer in a stack to refer to a location in the same stack.

As shown in Figure~\ref{memory_model}, the other three types of segments are component segments, heap segments, and transferable heap segments.
A component segment contains the statically allocated state of a component while a heap segment contains the dynamically allocated state.
A transferable heap segment is a dynamically allocated and self-contained group of objects that can be used to extend the state of a component and make such state transferable.
The semantics of reactive components require the state of each component to remain disjoint.
In terms of pointers, a pointer in a component segment may only refer to 1)~a location in the constant segment, 2)~a location in the same component segment, 3)~a location in the corresponding heap segment, or 4)~a transferable heap segment.
Similarly, a pointer in a heap segment may only refer to 1)~a location in the constant segment, 2)~a location in the same heap segment, 3)~a location in the corresponding component segment, or 4)~another heap segment.
A pointer in a transferable heap segment may only refer to 1)~a location in the constant segment, 2)~a location in the same transferable heap segment, or 3)~another heap segment.
Part of our approach to maintaining disjoint state is preventing the formation of arbitrary pointers that would allow one component to access the state of another component.
Consequently, pointer arithmetic and casts from numeric values are not allowed.
Manually deallocating memory may result in dangling pointers which, as memory is recycled, may point to the state of another component.
Consequently, some form of automatic memory management is necessary with the two primary candidates being reference counting and garbage collection.
Our implementation uses garbage collection and is described in Chapter~\ref{implementation}.
The component segments and heap segments contain all of the mutable state in the system.
Mutable state outside of a component, e.g., a global variable, is prohibited as it may introduce a data race.
%% Logically, then, each component has its own heap from which it can allocate memory.

%% Let $f(c)$ be a function that returns an address range $[c,c+sizeof(T))$ if $c$ is a pointer and $\emptyset$ otherwise.
%% Let $c$ be a pointer to a component of type $T$.
%% Assuming statically allocated components, the range of addresses $S = f(c)$ refers to a block of locations with the same size as $T$ in the static component segment.
%% That is $S$ contains the range of addresses for the \emph{statically} allocated state of the component indicated by $c$.
%% Let $F(A) = \cup_{a \in A} f(a)$.
%% Let $C$ be the transitive closure of $F$ applied to $S$.
%% $C$ contains the set of memory addresses that contain the state of component $c$.
%% The set $H = C \setminus S$ contains the \emph{dynamically} allocated state of the component indicated by $c$.
%% Dynamically allocated state is contained in a heap.
%% Let $c_x$ and $c_y$ be two different components and their corresponding state $C_x$ and $C_y$.
%% The semantics of reactive components require that the state of each component be disjoint or $C_x \cap C_y = \emptyset$.
%% The static component segment and the heaps contain all of the mutable state in the system.
%% Mutable state outside of a component, e.g., a global variable, is prohibited as it may introduce a data race.

\section{Reactive Component Programming Language}

This section describes the syntax and semantics for a programming language for reactive components.
Many concepts, e.g., components, ports, actions, and reactions, have a natural mapping into the Go language as types and method-like constructs.
A major divergence from Go is the introduction of attributes that change the mutability of variables as this was necessary to maintain the isolation between components while supporting reference semantics.
The separation between the immutable phase and mutable phase is accomplished via an \verb+activate+ statement that contains a closure to be executed in the mutable phase.
To support move semantics, we introduce a new type called a \emph{transferable heap} which allows one component to safely transfer a collection of objects to another component.

\paragraph{Components.}
A reactive component resembles a \verb+struct+ in Go since it is a group of named state variables.
A component, then, is defined with the following syntax:
\begin{verbatim}
type identifier component { field list };
\end{verbatim}
For example,
\begin{verbatim}
type Clock component {
  flag bool;
  counter uint;
};
\end{verbatim}
introduces a type named \verb+Clock+ that is a reactive component with two fields (state variables).
The type of a field may be another component type to support recursive encapsulation.

\paragraph{Receivers.}
A method in Go has one of the following two forms:
\begin{verbatim}
func (identifier typeName) methodName signature body
func (identifier *typeName) methodName signature body
\end{verbatim}
The first form operates on a copy of a value of type \verb+typeName+.
The second form operates on a pointer to a value of type \verb+typeName+.
The parameter \verb+identifier+ performs the same function as the \verb+this+ keyword in C++ and Java.
The syntax \verb+(identifier typeName)+ is called a receiver and the syntax \verb+(identifier *typeName)+ is called a pointer receiver.
Actions, reactions, getters, and initializers use a pointer receiver.

\paragraph{Intrinsic and dereference mutability.}
Variables and parameters may be declared with an \emph{intrinsic mutability} and a \emph{dereference mutability}.
Intrinsic mutability limits the operations that can be performed on the lvalue of the variable or parameter while dereference mutability limits the operations that can be performed on lvalues derived from the rvalue of the variable or parameter.
By default, variables and parameters have mutable intrinsic and dereference mutability.
The following code is legal and sets \verb+z+ to 6.
\begin{verbatim}
var x uint = 3;
var y *uint = &x;
var z = x + *y;
\end{verbatim}

Declaring a variable or parameter to have immutable intrinsic mutability (\verb+const+) prevents the variable or parameter from being changed after it is initialized.
The following code is illegal:
\begin{verbatim}
var x const uint = 3;
x = 4; // Illegal
\end{verbatim}
Immutable intrinsic mutability is enforced when taking the address of a variable or parameter:
\begin{verbatim}
var x const uint = 3;
var y *uint = &x;        // Illegal
var z $const *uint = &x; // Legal
var a uint = *z;         // Legal
*z = 5;                  // Illegal
\end{verbatim}
The second line is illegal because \verb+x+ could change through a statement like \verb+*y = 5;+.
The third line causes \verb+z+ to have immutable dereference mutability (\verb|$const|).
The expression \verb+*z+ can serve as an rvalue (line 4) but it cannot serve as an lvalue (line 5).

Dereference mutability is ``sticky.''
For example:
\begin{verbatim}
var x $const **uint = ...;
var y $const *uint = *x; // Legal
var z *uint = *x;        // Illegal
\end{verbatim}
The second line honors the guarantee that all of the memory accessible through \verb+x+ is immutable.
Dereference mutability is checked in assignments and calls.
Dereference mutability affects types from which lvalues can be derived, namely, pointers and slices\footnote{A \emph{slice} represents a portion of an array and consists of a pointer, a size, and a capacity.}.
Immutable dereference mutability is one of the techniques that is used to enforce the immutable phase of state transitions.

The second kind of mutability is called \emph{foreign} mutability.
Foreign mutability is like immutable mutability with the added condition that an address with foreign mutability cannot be stored in a component segment or heap segment.
The primary application of foreign mutability is to support reference semantics for communication while enforcing the isolation of heaps.
\begin{verbatim}
var x $foreign *uint = ...;
var y **uint = new (*uint);
*x = 3;                            // Illegal
*y = x;                            // Illegal
var z $foreign *uint = x;          // Legal
\end{verbatim}
The third line is illegal because the lvalue given by \verb+*x+ is immutable.
The fourth line is illegal because it casts away the \verb|$foreign| attribute of \verb+x+.
(Notice that declaring \verb+y+ with \verb|$foreign| would cause the lvalue to be immutable.)
The fifth line is legal because the lvalue is mutable and the \verb|$foreign| attribute is preserved.
The consequence of these semantics is that variables that contain pointers that are declared \verb|$foreign| may only be stored in stack segments.

%% Table~\ref{mutability} describes how the intrinsic and dereference mutability is computed for various expressions.
%% The operation of interest is the dereference operation which shows how dereference mutability is ``sticky'' and conservatively assumes that all pointers refer to an address on the heap.

The following checks are applied to assignment statements:
\begin{enumerate}
\item The lvalue and rvalue must be type compatible.
\item The lvalue must have mutable intrinsic mutability.
\item If the type involved contains a pointer, check for compatible dereference mutability (see Table~\ref{assignmut}).
  Essentially, the dereference mutability of the lvalue must be at least as ``weak'' as the dereference mutability of the rvalue.
  This enforces the ``stickiness'' of dereference mutability.
\end{enumerate}

%% \begin{table}
%%   \centering
%%   \begin{tabular}{ccccp{1.75cm}cccc}
%%     Kind & Seg & Intrin & Deref & Op & Kind & Seg & Intrin & Deref \\
%%     \hline
%%     lvalue & S & A & B & load              & rvalue & S    & A & B \\
%%     rvalue & S & A & B & deref (\verb+*+)  & lvalue & heap & B & B \\
%%     lvalue & S & A & B & ref (\verb+&+)    & rvalue & S    & A & B \\
%%     lvalue & S & A & B & select (\verb+.+) & lvalue & S    & A & B \\
%%     lvalue & S & A & B & index (\verb+[]+) & lvalue & S    & A & B \\
%%   \end{tabular}
%%   \caption{Intrinsic and dereference mutability for various operations\label{mutability}.  The possible choices for segment are constant, stack or heap (includes the component segment).  The possible choices for the intrinsic and dereference mutability are mutable, immutable, and foreign.}
%% \end{table}

\begin{table}
  \centering
  \begin{tabular}{cccc}
              & Mutable & Immutable & Foreign \\
    Mutable   & Yes     & No        & No      \\
    Immutable & Yes     & Yes       & No      \\
    Foreign   & Yes     & Yes       & Yes     \\
    \end{tabular}
  \caption{Dereference mutability compatibility for assignment.  The rows represent the dereference mutability of the lvalue and the columns represent the dereference mutability of the rvalue.\label{assignmut}}
\end{table}

A parameter is \emph{foreign safe} if 1) the type of the parameter does not contain pointers or slices or 2) the parameter is declared with foreign dereference immutability.
A parameter list is foreign safe if all parameters in the list are foreign safe.
A signature (a parameter list with a return parameter) is foreign safe if the parameter list and return parameter are both foreign safe.
Signatures used in inter-component communication, such as push ports and reactions, must be foreign safe to permit reference semantics while enforcing the isolation of state between components.

\paragraph{Initializers.}
An initializer is used to initialize the fields of a reactive component.
This allows one to initialize components before the scheduler starts.
This is necessary for establishing invariants as is commonly done in formal models, e.g., the \verb+initially+ section of UNITY~\cite{chandy1989parallel}.
An initializer has the form:
\begin{verbatim}
init (id *typeName) initializerName signature body
\end{verbatim}
An initializer is similar to a method but has additional semantics:
\begin{itemize}
\item An initializer must have a pointer receiver to a component type.
\item The signature must be foreign safe.
\item An initializer may only be invoked by another initializer.
\item An initializer sets the heap on entry and resets the heap on exit so that all allocated memory is attributed to the receiver.
\end{itemize}

\paragraph{Instances.}
An instance is a top-level component.
An instance is declared with the following syntax:
\begin{verbatim}
instance identifier typeIdentifier initializerIdentifier (expressionList);
\end{verbatim}
For example, \verb+instance c Clock Init ();+ declares as instance named \verb+c+ of type \verb+Clock+ and will call the initializer \verb+Init+ with an empty list of arguments.
The instance identifier must be unique, the type identifier must refer to a component, and the initializer must be declared for the component type.

\paragraph{Actions.}
An action has the form:
\begin{verbatim}
action (id $const *typeName) identifier (booleanExpression) body
\end{verbatim}
The immutable dereference mutability of the receiver enforces the immutable phase of transactions.
Actions may only be defined for component types.
The Boolean expression is the precondition of the action.
The receiver variable is in scope for the evaluation of the precondition.
The body contains the state transitions associated with the action.
Actions set the heap on entry and reset the heap on exit so that all allocated memory is attributed to the receiver.

\paragraph{Reactions.}
A reaction has the form:
\begin{verbatim}
reaction (id $const *typeName) identifier (parameterList) body
\end{verbatim}
As with actions, the immutable dereference mutability of the receiver enforces the immutable phase of transactions.
Reactions may only be defined for component types.
The name of a reaction is used when binding to push ports.
The parameter list declares the parameters that are passed to the reaction.
The parameter list must be foreign safe.
This prevents the reaction from storing memory addresses from the component that activated the reaction.
The body contains the state transitions associated with the reaction.
Reactions set the heap on entry and reset the heap on exit so that all allocated memory is attributed to the receiver.

\paragraph{Push ports.}
A push port is declared as a field (of a component) with push port type.
A push port type has the form:
\begin{verbatim}
push (parameterList)
\end{verbatim}
The parameter list declares the parameters that are passed to any bound reaction.
The parameter list must be foreign safe.
The following example declares a push port named \verb+response+ in the \verb+Clock+ component:
\begin{verbatim}
type Clock component {
  ...
  response push (t uint);
};
\end{verbatim}

\paragraph{Getters.}
A getter, which provides a safe way of obtaining information from a component, has the form:
\begin{verbatim}
getter (id $const *typeName) identifier signature body
\end{verbatim}
A getter is similar to a method but has additional semantics:
\begin{itemize}
\item A getter must have a pointer receiver to a component type declared with immutable dereference mutability.
\item The signature must be foreign safe.
\item A getter may only be invoked by an initializer, another getter, or an action or reaction in the immutable phase.
\item A getter sets the heap on entry and resets the heap on exit so that all allocated memory is attributed to the receiver.
\end{itemize}

\paragraph{Pull ports.}
A pull port is declared as a field (of a component) with pull port type.
A pull port type has the form:
\begin{verbatim}
pull (parameterList) returnParameter
\end{verbatim}
The parameter list declares the parameters that are passed to the bound getter.
The parameter list and return parameter must be foreign safe.
Pull ports are called like getters and place the same restriction on the caller, that is, a pull port may only be invoked by a getter or an action or reaction in the immutable phase.
The following example declares a pull port named \verb+isBufferFull+ in the \verb+Producer+ component:
\begin{verbatim}
type Producer component {
  ...
  isOutputBufferFull pull () bool;
};
\end{verbatim}
In this example, the intent of the pull port is to allow a \verb+Producer+ to interrogate the status of a downstream buffer to implement flow control.

\paragraph{Binders.}
Binders allow reactions to be associated with push ports and getters to be associated with pull ports.
Binding and recursive encapsulation are the two mechanisms for composing reactive components.
A binder has the form:
\begin{verbatim}
bind (id *typeName) identifier {
  bindStatement
  ...
}
\end{verbatim}
For example:
\begin{verbatim}
bind (this *System) TheBinder {
  this.producer.Out -> this.consumer.In;
  this.producer.isOutputBufferFull <- this.consumer.isInputBufferFull;
}
\end{verbatim}
The first statement of the example binds the \verb+Out+ push port of the \verb+System+'s \verb+producer+ to the \verb+In+ reaction of the \verb+System+'s \verb+consumer+\footnote{The select operator(\texttt{.}) automatically dereferences pointers.}.
The second statement of the example binds the \verb+isOutputBufferFull+ pull port of the \verb+System+'s \verb+producer+ to the \verb+isInputBufferFull+ getter of the \verb+System+'s \verb+consumer+.
The left side of a bind statement always refers to a port while the right side refers to a getter or action.
The direction of the arrow indicates the logical flow of information.
Thus, information flows from a push port to a reaction (\verb+->+) and information flows from a getter to a pull port (\verb+<-+).
A pull port must be bound to exactly one getter.
A reaction may be bound to at most one push port.
Binders are associated with a component type and evaluated for each instance of that component type.

\paragraph{Activations.}
Activations are the mechanism by which transactions extend to other components via push port/reaction bindings.
Activations also serve as the boundary between the immutable and mutable phases of a transaction.
An activate statement has the form:
\begin{verbatim}
activate portName (arguments) ... {
  statements
};
\end{verbatim}
Activate statements can only occur in the body of an action or a reaction.
Assume that the receiver of the action or reaction is named \verb+this+\footnote{\verb+this+ is not a keyword in Go.}.
The expression \verb+this.portName+ must refer to a push port and the arguments passed to the push port must agree with its signature.
The list of push ports in an activate statement is optional.
When an activate statement is executed, the named push ports are activated meaning that the reactions bound to those push ports are executed with the given arguments.
These reactions, in turn, may execute other activate statements.
%% This chaining of activations forms a transaction that resembles a tree where the root of the tree is a component/action pair, the other nodes are component/reaction pairs, and the links represent port activations.
Once all of the actions and reactions in the transaction have activated their last push ports, they proceed to execute the bodies of the activate statements.
Recall that the receiver \verb+this+ has immutable dereference mutability.
Thus, all computation up to and including the last port activation constitutes the immutable phase of the transaction since the state of the components is not allowed to change.
Within the scope of the body, the receiver \verb+this+ changes to mutable dereference mutability which then allows the state of a component to be changed.
Thus, the bodies of activate statements form the mutable phase of the transaction.
Actions and reactions return, i.e., their flow of control is halted, after the execution of the body of a activate statement.
Activate statements guarded by \verb+if+ statements facilitate \emph{conditional activation}.
An activate statement may not appear in another activate statement.

\paragraph{Arrays.}
A homogeneous group of sub-components may be declared using array syntax.
For example,
\begin{verbatim}
type System component {
  clock [5]Clock;
  ...
};
\end{verbatim}
declares 5 \verb+Clock+ sub-components.
To request the time from each \verb+Clock+, the \verb+System+ declares as array of 5 push ports and a \emph{dimensioned} action:
\begin{verbatim}
type System component {
  clock [5]Clock;
  push [5]request ();
  ...
};

[5] action (this $const *System) (...) {
  ...
  activate clock[IOTA] {
    ...
  };
}
\end{verbatim}
A dimensioned action is parameterized with an integral constant in the range $[0,dimension)$.
This constant is accessed through the \verb+IOTA+ symbol.
A push port in an array is activated by supplying an index.
The index expression must be constant to facilitate the check for sound composition.
Reactions may be dimensioned as well:
\begin{verbatim}
[5] reaction (this $const *System) clock (t int) { ... }
\end{verbatim}
A \verb+for+-loop over an integral range may be used to generate bindings without explicitly listing each binding.
For example:
\begin{verbatim}
bind (this *System) {
  for i ... 5 {
    this.request[i] -> this.clock[i].request;
  };
}
\end{verbatim}

\paragraph{Transferable heaps.}
A key requirement for implementing reactive components is that the state of each component remain disjoint.
Foreign dereference mutability allows components to safely communicate with pointers because it ensures that those pointers are forgotten after the transaction.
For efficient communication, we also desire the ability to transfer a data structure (a heap) from one component (the sender) to another component (the receiver).
The sender offers the heap to its receivers and one of the receivers may claim the heap.
If the heap is accepted, the sender must forget all references to the heap.

The heap type is so named because it resembles a heap used for dynamic memory allocation.
A heap has a distinguished root that contains the data structure that will be transferred.
A heap is entirely self-contained, that is, any pointer found in the heap may only point to an address in the heap or another transferable heap segment.
This ensures that the receiver may not access state in the sender after a transfer.
Heaps may form hierarchies.

A heap is created with the \verb+new+ operator.
For example:
\begin{verbatim}
var x *heap int = new (heap int);
\end{verbatim}
creates new heap with an integer root.

A \verb+change+ statement allows one to access the root of the heap.
For example:
\begin{verbatim}
change (x, y) {
  *y = 3;
};
\end{verbatim}
In the example, \verb+x+ is a pointer to a heap and \verb+y+ is a variable that points to the root of the heap.
The root variable is valid for the scope introduced by the \verb+change+ statement.
The root variable will be set to \verb+nil+ if the heap is no longer valid.
Within the scope of the \verb+change+ statement, all other variables and parameters are re-entered with foreign dereference immutability.
This enforces the isolation of heaps by preventing the heap from storing a pointer that refers to a location in another heap.

Logically, the runtime maintains a stack of heaps.
The top of the stack is called the \emph{active heap} and is used to service all memory allocation requests.
On entering an action or reaction, the stack of heaps contains a single heap:  the heap associated with the receiver component.
A \verb+change+ statement pushes a new heap on the stack.

A \verb+move+ expression allows a receiver to take ownership of a heap being offered by a sender.
For example:
\begin{verbatim}
var z *heap int = move (x);
\end{verbatim}
If \verb+x+ refers to a heap that has already been moved, i.e., claimed by this component or another component, then the result of the \verb+move+ is a \verb+nil+ pointer.
A \verb+change+ statement can be used to access the data in the heap after a successful \verb+move+.

A \verb+merge+ expression allows one to merge a heap into the active heap.
For example:
\begin{verbatim}
var x *uint = merge (z);
\end{verbatim}
A \verb+merge+ expression performs an implicit \verb+move+, that is, the heap given to \verb+merge+ need not be owned by the current component.
Similarly, a \verb+merge+ will return \verb+nil+ if the heap has already been claimed.

Operations on heaps, specifically, \verb+change+, \verb+move+, and \verb+merge+ are atomic within a transaction.
The reactive component model requires a clear distinction between the mutable phase and immutable phase and some causality in the immutable phase.
However, an implementation is free to execute immutable phases concurrently and/or mutable phases concurrently.
Consequently, different components may be performing heap operations on the same heap at the same time.
Thus, \verb+change+, \verb+move+, and \verb+merge+ are atomic with respect to each other.
These operations return \verb+nil+ indicating a failure.
For example, if two components attempt to \verb+move+ the same heap, one will succeed and the other will fail.

\section{Examples}

To demonstrate our reactive component programming language, we present two examples.
The first example simulates three users using three processes which communicate using a shared variable.
This example shows all of the major syntactic elements such as component types, initializers, action, reactions, getters, push ports, pull ports, binders, activate statements, arrays, and \verb+$const+.
The second example consists of a system and a channel.
The system sends an object to the channel and then receives the object from the channel.
This example demonstrates the heap type, \verb+$foreign+, \verb+new+, \verb+change+, \verb+move+, and \verb+merge+.

\subsection{Shared Variable System}

In this example, we rewrite the shared variable I/O automaton on pages 240 and 242 of~\cite{nancy1996distributed} as a reactive component.
The example consists of four kinds of components.
First, there is a \verb+Variable+ component which represents a shared variable.
\verb+Process+ components access the shared variable and report the status of the shared variable to \verb+User+ components.
A top-level \verb+System+ component instantiates the shared variable, three processes, and three users to create a complete system.

\begin{figure}
\begin{verbatim}
type Variable component {
    value int;
};

init (this *Variable) Init () {
    this.value = -1;
}

[3] reaction (this $const * Variable) Set (v int) {
    activate {
        this.value = v;
    }
}

getter (this $const * Variable) Get () int {
    return this.value;
}
\end{verbatim}
\cprotect\caption{Code listing for \verb+Variable+ component \label{variable}}
\end{figure}

Figure~\ref{variable} contains the listing for the \verb+Variable+ component.
A \verb+Variable+ component has a single integer state variable named \verb+value+.
This variable is initialized to the sentinel value -1 in the initializer \verb+Init+.
Notice that the initializer has a pointer receiver \verb+(this *Variable)+.
The receiver \verb+this+ has mutable dereference mutability so that the state variable can be assigned.
The value of the \verb+Variable+ is set in the dimensioned reaction \verb+Set+.
The reaction has a dimension of three as three \verb+Process+ actions will be bound to this reaction.
The new value for the variable is communicated via the parameter \verb+v+.
Notice that the receiver for the reaction \verb+(this $const * Variable)+ has immutable dereference mutability.
In the body of the activate statement, the receiver is implicitly converted to have mutable dereference mutability.
The final element of the \verb+Variable+ component is the getter \verb+Get+ that returns the value of the variable.
Since getters are not allowed to change the state of the component, they must be declared with immutable dereference mutability \verb+(this $const * Variable)+.

\begin{figure}
\begin{verbatim}
type ProcessStatus int;
const PROCESS_IDLE = 0;
const PROCESS_ACCESS = 1;
const PROCESS_DECIDE = 2;
const PROCESS_DONE = 3;

type Process component {
    status ProcessStatus;
    input int;
    output int;
    get_x pull () int;
    set_x push (v int);
    Decide push (v int);
};

init (this *Process) Init () {
    this.status = PROCESS_IDLE;
    this.input = -1;
    this.output = -1;
}

reaction (this $const * Process) initr (v int) {
    activate {
        this.input = v;
        if this.status == PROCESS_IDLE {
            this.status = PROCESS_ACCESS;
        }
    }
}

action (this $const * Process) _access (this.status == PROCESS_ACCESS) {
    x := this.get_x ();
    if x == -1 {
        activate set_x (this.input) {
            println (`x set to `, this.input);
            this.output = this.input;
            this.status = PROCESS_DECIDE;
        }
    }
    else {
        activate {
            this.output = x;
            this.status = PROCESS_DECIDE;
        }
    }
}

action (this $const * Process) _decide (this.status == PROCESS_DECIDE) {
    activate Decide (this.output) {
        this.status = PROCESS_DONE;
    }
}
\end{verbatim}
\cprotect\caption{Code listing for \verb+Process+ component \label{process}}
\end{figure}

Figure~\ref{process} contains the listing for the \verb+Process+ component.
The listing begins by defining the states for a process, that is, a process is either idle, ready to access the shared variable, ready to decide, or done.
A \verb+Process+ component consists of three state variables:  \verb+status+ contains the state of the process, \verb+input+ contains a value received from the \verb+User+, and \verb+output+ contains the value that will be sent to the \verb+User+.
The \verb+Process+ component contains a pull port \verb+get_x+ that will be bound to the shared variable's \verb+Get+ getter so that the \verb+Process+ may access the shared variable.
Similarly, the \verb+Process+ component contains a \verb+set_x+ push port that will be bound to the shared variable's \verb+Set+ reaction to set the value of the variable.
To communicate with the \verb+User+, the \verb+Process+ component contains a push port \verb+Decide+ that communicates the value of the shared variable.

Like the \verb+Variable+ component, the \verb+Process+ component contains an initializer \verb+Init+ that sets the initial value of the state variables.
From the listing, \verb+Process+ components are initialized to the idle state and the \verb+input+ and \verb+output+ variables are initialized to the sentinel value of -1.
The \verb+initr+ reaction allows a \verb+User+ to asynchronously initialize the \verb+Process+ component.
From the listing, this reaction sets the \verb+input+ variable to the value supplied in the argument \verb+v+ and causes the \verb+Process+ to prepare to access the shared variable if the \verb+Process+ was previously idle.

The most interesting part of the \verb+Process+ component is the \verb+_access+ action.
Like reactions, actions honor the immutable phase by requiring a receiver with immutable dereference mutability \verb+(this $const * Process)+.
The precondition for \verb+_access+ tests that the \verb+Process+ is ready to access the shared variable.
When executed, the \verb+_access+ action samples the state of the shared variable by calling the \verb+get_x+ pull port and assigns this to the local variable \verb+x+.
Note that pull ports may only be called in the immutable phase.
If the shared variable has not been set as indicated by the sentinel value -1, the process sets it to the value requested by the \verb+User+ (\verb+this.input+) by activating the \verb+set_x+ push port.
Once the mutable phase begins, the \verb+Process+ outputs a message, copies the \verb+input+ variable to the \verb+output+ variable, and then changes state to prepare to decide.
If the shared variable has been set, i.e., another process executed its \verb+_access+ action first, the process sets its \verb+output+ variable to the value of the shared variable as stored in \verb+x+ and prepares to decide.

The final element in the \verb+Process+ component is the \verb+_decide+ action which activates the \verb+Decide+ push port with the value of the shared variable stored in the \verb+output+ variable and transitions to the done state.

The interface of the \verb+Process+ component gives hints as to its contextual dependencies and intended use.
The \verb+Process+ component expects an initialization message (\verb+initr+ reaction) from the \verb+User+ and will report back to the \verb+User+ (\verb+Decide+ push port).
The \verb+Process+ component requires the ability to interrogate the value of the shared variable (\verb+get_x+ pull port) and the ability to the set the shared variable (\verb+set_x+ push port).

The state transitions of a \verb+Process+ component can be determined by tracing the \verb+status+ variable.
A \verb+Process+ component starts in the idle state according to the \verb+Init+ initializer.
The \verb+Process+ will stay idle until its \verb+initr+ reaction is activated at which point it will enter the access state.
Given the weak fairness guarantees of the scheduler, the \verb+_access+ action will eventually be selected and executed as the \verb+Process+ is in the access state.
The execution of \verb+_access+ is governed by an \verb+if+ statement but both branches set the state of the \verb+Process+ component to decide.
Given the same weak fairness guarantees, the \verb+_decide+ action will eventually be selected and executed as the \verb+Process+ is in the decide state.
The \verb+_decide+ action unconditionally sets the state of the component to done.
There is no way for a \verb+Process+ component to leave the done state as all of its actions are conditioned on the \verb+Process+ being in either the access or decide state.
Similarly, the \verb+initr+ reaction only moves the \verb+Process+ from the idle to the access state.
Thus, the state of the component logically flows from idle, to access, to decide, to done assuming that the \verb+User+ does indeed activate the \verb+initr+ reaction.

The preceding two paragraphs illustrate how the reactive component model and the proposed programming language achieve principled composition.
The behavior of a component can be determined by only examining the text of the component.
The is possible due to the strong guarantees that 1) component state cannot be manipulated outside of an action or reaction, 2) actions and reactions are logically atomic, and 3) the scheduler will eventually select and execute all enabled actions.
For compositional reasoning, the behavior of a component can be abstracted and stated in terms of assumptions and guarantees~\cite{Jones:1983:TST:69575.69577} about its interface elements, namely, push ports, reaction, pull ports, and getters.
For example, a \verb+Process+ component will decide the value of the shared variable when initialized via the \verb+initr+ reaction.

\begin{figure}
\begin{verbatim}
type UserStatus int;
const USER_REQUEST = 0;
const USER_WAIT = 1;
const USER_DONE = 2;

type User component {
    v int;
    status UserStatus;
    decision int;
    error bool;
    initp push (v int);
};

init (this *User) Init (v int) {
    this.v = v;
    this.status = USER_REQUEST;
    this.decision = -1;
    this.error = false;
}

action (this $const * User) _init (this.status == USER_REQUEST || this.error) {
    activate initp (this.v) {
        if !this.error {
            this.status = USER_WAIT;
        }
    }
}

action (this $const * User) _dummy (this.error) { }

reaction (this $const * User) Decide (v int) {
    println (this, ` decided value is `, v);
    activate {
        if !this.error {
            if this.status == USER_WAIT {
                this.decision = v;
                this.status = USER_DONE;
            } else {
                this.error = true;
            }
        }
    }
}
\end{verbatim}
\cprotect\caption{Code listing for \verb+User+ component \label{user}}
\end{figure}

Figure~\ref{user} contains the listing for the \verb+User+ component.
The \verb+User+ component has three states indicating the user is waiting to make a request, waiting for a response, or done.
The first state variable \verb+v+ contains the value sent in the request to a \verb+User+.
The \verb+status+ state variable contains the state of the \verb+User+.
The \verb+decision+ state variable contains the value of the response.
The \verb+error+ state variable is a flag indicating that an error has occurred.
\verb+User+ components contain a push port \verb+initp+ that sends the requested value to the corresponding \verb+Process+.

The \verb+Init+ initializer sets the requested value to the supplied parameter, the state of the \verb+User+ to request, the \verb+decision+ variable to the sentinel value of -1, and the \verb+error+ flag to false.
The \verb+_init+ action moves the \verb+User+ component from the request state to the waiting state while initializing the corresponding \verb+Process+ component via the \verb+initp+ push port.
The \verb+_dummy+ action and the treatment of the \verb+error+ flag by the \verb+_init+ action are for consistency with~\cite{nancy1996distributed}.
The \verb+Decide+ reaction prints out the identity of the \verb+User+ and the value received by the \verb+User+.
If the \verb+User+ is not in an error condition and waiting for a response, then the value of the decision is recorded and the \verb+User+ changes to the done state.
Otherwise, the \verb+error+ flag is set meaning that the corresponding \verb+Process+ activated the \verb+Decide+ reaction before the \verb+_init+ action.

\begin{figure}
\begin{verbatim}
type System component {
    x Variable;
    process [3]Process;
    user [3]User;
};

init (this *System) Init () {
    this.x.Init ();
    for i ... 3 {
        this.process[i].Init ();
        this.user[i].Init (i + 100);
    }
}

bind (this *System) _bind {
    for i ... 3 {
        this.process[i].get_x <- this.x.Get;
        this.process[i].set_x -> this.x.Set ... i;
        this.user[i].initp -> this.process[i].initr;
        this.process[i].Decide -> this.user[i].Decide;
    }
}

instance s System Init ();
\end{verbatim}
\cprotect\caption{Code listing for \verb+System+ component \label{system}}
\end{figure}

Figure~\ref{system} contains the listing for the \verb+System+ component.
The system component contains a \verb+Variable+ sub-component, three \verb+Process+ sub-components, and three \verb+User+ sub-components.
The \verb+Init+ initializer initializes all of the sub-components.
The \verb+User+ processes are initialized with the values 100, 101, and 102.
Thus, \verb+User+ 0 will attempt to set the \verb+Variable+ to 100, \verb+User+ 1 will attempt to set the \verb+Variable+ to 101, and \verb+User+ 2 will attempt to set the \verb+Variable+ to 102.
The \verb+_bind+ binder ``wires'' the system.
The first line of the \verb+for+ loop binds the \verb+get_x+ pull port of each \verb+Process+ to the \verb+Get+ getter of the \verb+Variable+.
The second line of the \verb+for+ loop binds the \verb+set_x+ push port of each \verb+Process+ to the \verb+Set+ reaction of the \verb+Variable+.
Notice that the \verb+Set+ reaction is indexed to avoid binding the same input multiple times.
The third line of the \verb+for+ loop binds the \verb+initp+ push port of each \verb+User+ to the \verb+initr+ reaction of each \verb+Process+.
The fourth line of the \verb+for+ loop binds the \verb+Decide+ push port of each \verb+Process+ to the \verb+Decide+ reaction of each \verb+User+.
The final line of the listing creates an instance of the \verb+System+ component named \verb+s+ and initializes it with the \verb+Init+ initializer.
Figure~\ref{system_instance} shows a graphical representation of a \verb+System+ component.

\begin{figure}
\centering
\resizebox{\textwidth}{!}{%
\begin{tikzpicture}

%% User 0
\draw (2,7.5) rectangle (5,10);
\node[below] at (3.5,10) {User 0};
\rapush[5,9,2.2,.5,u0i,ignore]{initp(v int)};
\rppush[5,8,2.6,.5,u0d,ignore]{Decide(v int)};

%% User 1
\draw (2,4) rectangle (5,6.5);
\node[below] at (3.5,6.5) {User 1};
\rapush[5,5.5,2.2,.5,u1i,ignore]{initp(v int)};
\rppush[5,4.5,2.6,.5,u1d,ignore]{Decide(v int)};

%% User 2
\draw (2,.5) rectangle (5,3);
\node[below] at (3.5,3) {User 2};
\rapush[5,2,2.2,.5,u2i,ignore]{initp(v int)};
\rppush[5,1,2.6,.5,u2d,ignore]{Decide(v int)};

%% Process 0
\draw(6,7.5) rectangle (11,10);
\node[below] at (8.5,10) {Process 0};
\lppush[6,9,2.3,.5,p0i,ignore]{initr(v int)};
\lapush[6,8,2.4,.5,p0d,ignore]{Decide(v int)};

\rapull[11,9,2.3,.5,p0g,ignore]{get\_x() int)};
\rapush[11,8,2.2,.5,p0s,ignore]{set\_x(v int)};

%% Process 1
\draw(6,4) rectangle (11,6.5);
\node[below] at (8.5,6.5) {Process 1};
\lppush[6,5.5,2.3,.5,p1i,ignore]{initr(v int)};
\lapush[6,4.5,2.4,.5,p1d,ignore]{Decide(v int)};

\rapull[11,5.5,2.3,.5,p1g,ignore]{get\_x() int)};
\rapush[11,4.5,2.2,.5,p1s,ignore]{set\_x(v int)};

%% Process 2
\draw(6,.5) rectangle (11,3);
\node[below] at (8.5,3) {Process 2};
\lppush[6,2,2.3,.5,p2i,ignore]{initr(v int)};
\lapush[6,1,2.4,.5,p2d,ignore]{Decide(v int)};

\rapull[11,2,2.3,.5,p2g,ignore]{get\_x() int)};
\rapush[11,1,2.2,.5,p2s,ignore]{set\_x(v int)};

%% Variable
\draw (12,.5) rectangle (15,10);
\node[below] at (13.5,10) {Variable};
\lppull[12,5.5,2,.5,vg,ignore]{Get() int};
\lppush[12,8,2.5,.5,vs0,ignore]{[0] Set(v int)};
\lppush[12,4.5,2.5,.5,vs1,ignore]{[1] Set(v int)};
\lppush[12,1,2.5,.5,vs2,ignore]{[2] Set(v int)};

\draw (u0i.center) -- (p0i.center);
\draw (u1i.center) -- (p1i.center);
\draw (u2i.center) -- (p2i.center);

\draw (u0d.center) -- (p0d.center);
\draw (u1d.center) -- (p1d.center);
\draw (u2d.center) -- (p2d.center);

\draw (p1g.center) -- (vg.center);
\draw (p0g.center) -- +(.25,0) -- (vg.center);
\draw (p2g.center) -- +(.25,0) -- (vg.center);

\draw (p0s.center) -- (vs0.center);
\draw (p1s.center) -- (vs1.center);
\draw (p2s.center) -- (vs2.center);

\draw(1,-.5) rectangle (16,11);
\node[below] at (8.5,11) {System};

\end{tikzpicture}
}%
\cprotect\caption{Diagram of a \verb+System+ instance\label{system_instance}}
\end{figure}

\begin{figure}
\begin{verbatim}
x set to 102
0x1fd7258 decided value is 102
0x1fd71f8 decided value is 102
0x1fd7228 decided value is 102
\end{verbatim}
\cprotect\caption{Sample output for a \verb+System+ instance\label{system_output}}
\end{figure}

Figure~\ref{system_output} shows sample output for an execution of a \verb+System+ component.
The first line of output is generated by the \verb+_access+ action of the \verb+Process+ component.
In the sample, \verb+Process+ 2 is the first process to set the \verb+Variable+.
As expected, only one \verb+Process+ sets the variable.
The final three lines of output show the identity of each \verb+User+ and the value returned to it.
As expected, the value returned to each \verb+User+ is consistent with how the \verb+Variable+ was set.

\subsection{Heap Channel System}

In this example, we demonstrate how the \verb+heap+ data type may be used to transfer objects between components for efficient communciation.
The example consists of two components:  a top-level \verb+System+ component and a \verb+Channel+ component.
The \verb+Channel+ component is a reliable FIFO channel based on the Channel Automaton of~\cite{nancy1996distributed}.
The \verb+System+ component transfers 100 messages to the \verb+Channel+ component which then transfers the same 100 messages back to the \verb+System+.
The messages consists of a \verb+heap+ with a \verb+uint+ root object.

\begin{figure}
\begin{verbatim}
type Channel component {
  queue Queue;
  receive push (message $foreign *heap uint);
};

reaction (this $const * Channel) send (message $foreign *heap uint) {
  var x *heap uint = move (message);
  activate {
    this.queue.Push (x);
  };
}

action (this $const * Channel) _receive (!this.queue.Empty ()) {
  activate receive (this.queue.Front ()) {
    this.queue.Pop ();
  };
}
\end{verbatim}
\cprotect\caption{Listing for a \verb+Channel+ component\label{channel_listing}}
\end{figure}

Figure~\ref{channel_listing} contains the listing of the \verb+Channel+ component.
A \verb+Channel+ component consists of a queue of messages and a push port named \verb+receive+ which offers up a pointer to a heap with a \verb+uint+ root.
Since the parameter contains (is) a pointer, it must be declared with \verb+$foreign+ dereference mutability.
The elements of the \verb+Channel+ are named from the perspective of the process that uses the \verb+Channel+.

The \verb+send+ reaction moves the heap which makes the \verb+Channel+ the new owner of the heap.
Any heap operations on \verb+message+ after the move statement will return \verb+nil+.
The move occurs outside of the activation because the \verb+message+ parameter is not available in the body of the activation.
Parameters and variables with types that contain pointers and have foreign dereference mutability are not available in the body of an activate statement because they may represent the state of another component which must be assumed to be invalid in the mutable phase of a transaction.
After a move, the state contained in a heap is no longer available to the component that offered it up as an argument to a reaction.
Thus, the result of the move does not have foreign dereference mutability and is available in the body of the activate statement.

\begin{figure}
\begin{verbatim}
type System component {
  channel Channel;
  send_count uint;
  send push (message $foreign *heap uint);
};

init (this *System) Initially () { }

action (this $const * System) _send (this.send_count != 100) {
  var x *heap uint = new (heap uint);
  change (x, y) {
    *y = this.send_count;
  };
  activate send (x) {
    println (`Sent `, this.send_count);
    this.send_count++;
  };
}

reaction (this $const * System) receive (message $foreign *heap uint) {
  var x *uint = merge (message);
  println (`Received `, *x);
}

bind (this *System) Bind {
  this.send -> this.channel.send;
  this.channel.receive -> this.receive;
}

instance s System Initially ();
\end{verbatim}
\cprotect\caption{Listing for a \verb+System+ component that transfers heaps to and from a \verb+Channel+ component\label{channel_system_listing}}
\end{figure}

Figure~\ref{channel_system_listing} contains the listing for the \verb+System+ component that exercises the \verb+Channel+.
A \verb+System+ component consists of a \verb+Channel+ sub-component, a counter, and a push port for sending messages.
The \verb+_send+ action checks if the desired number of messages (100) has been sent.
If not, the \verb+System+ creates a new heap with a \verb+uint+ root.
It then makes the new heap the active heap via the \verb+change+ statement which also makes the root of the heap available in the variable \verb+y+.
The heap root is initialized with the number of messages sent so far.
The heap is then sent to the \verb+Channel+, a message is printed, and the number of sent messages is incremented.

The \verb+receive+ reaction receives a message back from the \verb+Channel+.
The \verb+System+ merges the message which moves the root object of a heap to the active heap and returns a pointer to the root object of the heap.
Recall that all components have a default heap which is the active heap upon entering an action, reaction, initializer, or getter.
The final statement in the reaction prints a message.

The system consists of two transactions:  one that creates and transfers the heap from the \verb+System+ to the \verb+Channel+ and another that transfers the heap from the \verb+Channel+ to the \verb+System+.
The output of the program, then, consists of 100 lines indicating that a message was sent and 100 lines indicating that a message was received.
Each line of output contains the message number.
Based on the weak fairness of the scheduler we expect 1) the 100 send lines to be in order, 2)~the 100 receive lines to be in order, and 3) the send line for message $n$ appears before the receive line for message $n$.

\section{Summary}

This chapter presents a programming language for reactive components.
An implementation of reactive components tests if the assumptions upon which the model rests are practical.
Our approach is to design a new programming language whose syntax and semantics  capture and enforce the semantics of reactive components.
As a matter of practicality, we impose support for reference semantics which allow developers to use linked data structures and the ability to transfer data structures from one component to another.
The corresponding features are a declarable dereference mutability that allows components to treat pointers as foreign and a heap data type that represents a self-contained linked data structure.
The programming language is based on Go.
Components are expressed as a collection of fields; similar to a \verb+struct+.
Ports (push and pull) are expressed as fields of a component.
Actions and reactions are expressed as method-like elements.
Composition is accomplished via binders and instances.

The programming language presented in this chapter allow developers to take a principled approach to developing general purpose reactive programs.
First, a developer need not identify shared state and add appropriate locking because state is not shared between components and each action/reaction is atomic.
Second, a developer need not ``worry'' about the consequences of composition.
In paradigms where composition is accomplished through synchronous function call, developers must determine the conditions in which it is safe to transfer control to a function.
In the reactive component paradigm, the semantics of active statements and ports provide strong guarantees when composing and checking for illegal composition becomes the responsibility of the runtime environment (see Chapter~\ref{implementation}).
Third, developers are no longer burdened with mapping an inherently non-deterministic sequence of events onto one or more sequential threads of control.
Thus, using a programming language for reactive components allows developers to move from explicit atomicity, sequential composition, and deterministic sequencing to \emph{implicit atomicity}, \emph{non-sequential composition}, and \emph{non-deterministic sequencing}.
Combined, the features of the model and language allow developers to reason about the behavior of individual components by only examining their text.
This, in turn, allows the behavior of a component to be abstracted which facilitates reasoning about components is the context of composition by using assume-guarantee reasoning~\cite{Jones:1983:TST:69575.69577}.
