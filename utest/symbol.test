/* -*- c++ -*- */
#include "unit_test.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "callable.hpp"
#include "visitor_helper.hpp"
#include "symbol_visitor.hpp"
#include "node.hpp"
#include "error_reporter.hpp"
#include "scope.hpp"
#include "package.hpp"
#include "astgen.hpp"
#include "symbol_table.hpp"
#include "identifier.hpp"
#include "decl.hpp"

using namespace type;
using namespace decl;
using namespace util;
using namespace ast;
using namespace source;

scope(decl); {
  Location loc = Location::builtin;
  ErrorReporter er;
  SymbolTable symbol_table;
  symbol_table.open_scope ();

  scope(Instance); {

    scenario(fully_constructed); {
      type::NamedType x (Identifier ("mytype", loc), &type::named_int);
      decl::Initializer init (gen_init_decl ("blah"), &x);
      Instance symbol (Identifier ("name", loc), &named_int, &init);

      unit(Instance); {
        ASSERT (symbol.identifier.identifier () == "name");
        ASSERT (symbol.identifier.location () == loc);
        ASSERT (symbol.type () == &named_int);
        ASSERT (symbol.initializer () == &init);
        ASSERT (symbol.instance == NULL);
      }; off();

      unit(offset); {
        symbol.offset (53);
        ASSERT (symbol.offset () == 53);
      }; off();

      scenario(SymbolVisitor); {
        unit(accept); {
          TestVisitor<SymbolVisitor, Instance> v;
          symbol.accept (v);
          ASSERT (v.item == &symbol);
          TestDefaultVisitor<SymbolVisitor, Symbol> w;
          symbol.accept (w);
          ASSERT (w.item == &symbol);
        }; off();
      }; off();

      scenario(ConstSymbolVisitor); {
        unit(accept); {
          TestConstVisitor<ConstSymbolVisitor, Instance> cv;
          symbol.accept (cv);
          ASSERT (cv.item == &symbol);
          TestDefaultConstVisitor<ConstSymbolVisitor, Symbol> w;
          symbol.accept (w);
          ASSERT (w.item == &symbol);
        }; off();
      }; off();
    }; off();

    scenario(from_decl); {
      scenario (no_type); {
        unit(process_declaration); {
          Identifier identifier ("i", loc);
          Identifier id2 ("T", loc);
          ast::IdentifierType type (loc, id2);
          Identifier init ("init", loc);
          ast::ExpressionList arguments (loc);
          ast::InstanceDecl instancedecl (loc, identifier, &type, init, &arguments);
          decl::Instance instance (&instancedecl);
          ASSERT (instance.process_declaration (er, symbol_table) == false);
          ASSERT (er.list ().size () == 1);
        }; off();
      }; off();

      scenario (not_a_component); {
        unit(process_declaration); {
          populate_universe_block (symbol_table);
          Identifier identifier ("i", loc);
          Identifier id2 ("int", loc);
          ast::IdentifierType type (loc, id2);
          Identifier init ("init", loc);
          ast::ExpressionList arguments (loc);
          ast::InstanceDecl instancedecl (loc, identifier, &type, init, &arguments);
          decl::Instance instance (&instancedecl);
          ASSERT (instance.process_declaration (er, symbol_table) == false);
          ASSERT (er.list ().size () == 1);
        }; off();
      }; off();

      scenario (no_initializer); {
        unit(process_declaration); {
          type::Component mycomp (NULL, loc);
          type::NamedType mytype (Identifier ("mytype", loc), &mycomp);
          symbol_table.enter_symbol (&mytype);

          Identifier identifier ("i", loc);
          Identifier id2 ("mytype", loc);
          ast::IdentifierType type (loc, id2);
          Identifier init ("init", loc);
          ast::ExpressionList arguments (loc);
          ast::InstanceDecl instancedecl (loc, identifier, &type, init, &arguments);
          decl::Instance instance (&instancedecl);
          ASSERT (instance.process_declaration (er, symbol_table) == false);
          ASSERT (er.list ().size () == 1);
        }; off();
      }; off();

      scenario (success); {
        unit(process_declaration); {
          type::Component mycomp (NULL, loc);
          type::NamedType mytype (Identifier ("mytype", loc), &mycomp);
          decl::Initializer initializer (gen_init_decl ("init"), &mytype);
          mytype.insert_initializer (&initializer);

          symbol_table.enter_symbol (&mytype);

          Identifier identifier ("i", loc);
          Identifier id2 ("mytype", loc);
          ast::IdentifierType type (loc, id2);
          Identifier init ("init", loc);
          ast::ExpressionList arguments (loc);
          ast::InstanceDecl instancedecl (loc, identifier, &type, init, &arguments);
          decl::Instance instance (&instancedecl);
          ASSERT (instance.process_declaration (er, symbol_table) == true);
          ASSERT (er.list ().size () == 0);
          ASSERT (instance.type () == &mytype);
          ASSERT (instance.initializer () == &initializer);
        }; off();
      }; off();

    }; off();
  }; off();

  scope(Parameter); {

    scenario(make); {

      Parameter* symbol = Parameter::make (Identifier ("name", loc), Immutable, Immutable, &named_int);

      unit(make); {
        ASSERT (symbol->identifier.identifier () == "name");
        ASSERT (symbol->identifier.location () == loc);
        ASSERT (symbol->type == &named_int);
        ASSERT (symbol->intrinsic_mutability == Immutable);
        ASSERT (symbol->indirection_mutability == Immutable);
        ASSERT (symbol->kind == Parameter::Ordinary);
      }; off();

      unit(offset); {
        static_cast<Symbol*> (symbol)->offset (53);
        ASSERT (symbol->offset () == 53);
      }; off();

      scenario(SymbolVisitor); {
        unit(accept); {
          TestVisitor<SymbolVisitor, Parameter> v;
          symbol->accept (v);
          ASSERT (v.item == symbol);
          TestDefaultVisitor<SymbolVisitor, Symbol> w;
          symbol->accept (w);
          ASSERT (w.item == symbol);
        }; off();
      }; off();

      scenario(ConstSymbolVisitor); {
        unit(accept); {
          TestConstVisitor<ConstSymbolVisitor, Parameter> cv;
          symbol->accept (cv);
          ASSERT (cv.item == symbol);
          TestDefaultConstVisitor<ConstSymbolVisitor, Symbol> w;
          symbol->accept (w);
          ASSERT (w.item == symbol);
        }; off();
      }; off();

      unit(duplicate); {
        Parameter* dup1 = symbol->duplicate (Mutable);
        Parameter* dup2 = dup1->duplicate (Foreign);
        static_cast<Symbol*> (symbol)->offset (34);
        ASSERT (dup1->identifier.identifier () == "name");
        ASSERT (dup1->identifier.location () == loc);
        ASSERT (dup1->type == &named_int);
        ASSERT (dup1->intrinsic_mutability == Immutable);
        ASSERT (dup1->indirection_mutability == Mutable);
        ASSERT (dup1->kind == Parameter::Ordinary_Duplicate);
        ASSERT (dup1->offset () == 34);
        ASSERT (dup2->indirection_mutability == Foreign);
        ASSERT (dup2->offset () == 34);
      }; off();

    }; off();

    unit(make_return); {
      Parameter* symbol = Parameter::make_return (Identifier ("name", loc), Immutable, &named_int);
      ASSERT (symbol->identifier.identifier () == "name");
      ASSERT (symbol->identifier.location () == loc);
      ASSERT (symbol->type == &named_int);
      ASSERT (symbol->intrinsic_mutability == Mutable);
      ASSERT (symbol->indirection_mutability == Immutable);
      ASSERT (symbol->kind == Parameter::Return);
    }; off();

    scenario(make_receiver); {

      Parameter* symbol = Parameter::make_receiver (Identifier ("name", loc), Immutable, Immutable, &named_int);

      unit(make_receiver); {
        ASSERT (symbol->identifier.identifier () == "name");
        ASSERT (symbol->identifier.location () == loc);
        ASSERT (symbol->type == &named_int);
        ASSERT (symbol->intrinsic_mutability == Immutable);
        ASSERT (symbol->indirection_mutability == Immutable);
        ASSERT (symbol->kind == Parameter::Receiver);
      }; off();

      unit(duplicate); {
        Parameter* dup1 = symbol->duplicate (Mutable);
        Parameter* dup2 = dup1->duplicate (Foreign);
        static_cast<Symbol*> (symbol)->offset (34);
        ASSERT (dup1->identifier.identifier () == "name");
        ASSERT (dup1->identifier.location () == loc);
        ASSERT (dup1->type == &named_int);
        ASSERT (dup1->intrinsic_mutability == Immutable);
        ASSERT (dup1->indirection_mutability == Mutable);
        ASSERT (dup1->kind == Parameter::Receiver_Duplicate);
        ASSERT (dup1->offset () == 34);
        ASSERT (dup2->indirection_mutability == Foreign);
        ASSERT (dup2->offset () == 34);
      }; off();
    }; off();

    unit(is_foreign_safe); {
      Parameter* safe1_symbol = Parameter::make (Identifier ("name", loc), Immutable, Immutable, &named_int);
      Parameter* safe2_symbol = Parameter::make (Identifier ("name", loc), Immutable, Foreign, named_int.get_pointer ());
      Parameter* unsafe_symbol = Parameter::make (Identifier ("name", loc), Immutable, Immutable, named_int.get_pointer ());

      ASSERT (safe1_symbol->is_foreign_safe ());
      ASSERT (safe2_symbol->is_foreign_safe ());
      ASSERT (!unsafe_symbol->is_foreign_safe ());
    }; off();
  }; off();

  scope(Constant); {

    scenario(fully_constructed); {
      semantic::ExpressionValue value;
      value.kind = semantic::ExpressionValue::Constant;
      value.type = &named_int;
      value.value.int_value = 37;
      Constant symbol (Identifier ("name", loc), value);

      unit(Constant); {
        ASSERT (symbol.identifier.identifier () == "name");
        ASSERT (symbol.identifier.location () == loc);
        ASSERT (symbol.value ().type == &named_int);
        ASSERT (symbol.value ().value.int_value == 37);
      }; off();

      scenario(SymbolVisitor); {
        unit(accept); {
          TestVisitor<SymbolVisitor, Constant> v;
          symbol.accept (v);
          ASSERT (v.item == &symbol);
          TestDefaultVisitor<SymbolVisitor, Symbol> w;
          symbol.accept (w);
          ASSERT (w.item == &symbol);
        }; off();
      }; off();

      scenario(ConstSymbolVisitor); {
        unit(accept); {
          TestConstVisitor<ConstSymbolVisitor, Constant> cv;
          symbol.accept (cv);
          ASSERT (cv.item == &symbol);
          TestDefaultConstVisitor<ConstSymbolVisitor, Symbol> w;
          symbol.accept (w);
          ASSERT (w.item == &symbol);
        }; off();
      }; off();
    }; off();

    scenario(from_decl); {

      scenario(with_type); {

        scenario(bad_type); {
          unit(process_declaration); {
            Identifier id1 ("not_declared", loc);
            IdentifierType type (loc, id1);
            semantic::ExpressionValue val;
            val.kind = semantic::ExpressionValue::Constant;
            val.type = type::UntypedInteger::instance ();
            Literal expr (loc, val);
            Constant myconst (Identifier ("myconst", loc), &type, &expr);
            ASSERT (myconst.process_declaration(er, symbol_table) == false);
            ASSERT (er.list ().size () == 1);
          }; off();
        }; off();

        scenario(not_constant); {
          unit(process_declaration); {
            populate_universe_block (symbol_table);
            Identifier id1 ("int", loc);
            IdentifierType type (loc, id1);
            Identifier id2 ("new", loc);
            ast::IdentifierExpression idx (loc, id2);
            ast::ExpressionList args (loc);
            Identifier id3 ("int", loc);
            ast::IdentifierType idtype2 (loc, id3);
            ast::TypeExpression tex (loc, &idtype2);
            args.append (&tex);
            ast::Call node (loc, &idx, &args);
            Constant myconst (Identifier ("myconst", loc), &type, &node);
            ASSERT (myconst.process_declaration(er, symbol_table) == false);
            ASSERT (er.list ().size () == 1);
          }; off();
        }; off();

        scenario(not_assignable); {
          unit(process_declaration); {
            populate_universe_block (symbol_table);
            Identifier id1 ("int", loc);
            IdentifierType type (loc, id1);
            semantic::ExpressionValue val;
            val.kind = semantic::ExpressionValue::Constant;
            val.type = type::UntypedFloat::instance ();
            val.value.untyped_float_value = 3.5;
            Literal expr (loc, val);
            Constant myconst (Identifier ("myconst", loc), &type, &expr);
            ASSERT (myconst.process_declaration(er, symbol_table) == false);
            ASSERT (er.list ().size () == 1);
          }; off();
        }; off();

        scenario(sucess); {
          unit(process_declaration); {
            populate_universe_block (symbol_table);
            Identifier id1 ("int", loc);
            IdentifierType type (loc, id1);
            semantic::ExpressionValue val;
            val.kind = semantic::ExpressionValue::Constant;
            val.type = type::UntypedFloat::instance ();
            val.value.untyped_float_value = 1.0;
            Literal expr (loc, val);
            Constant myconst (Identifier ("myconst", loc), &type, &expr);
            ASSERT (myconst.process_declaration(er, symbol_table) == true);
            ASSERT (er.list ().size () == 0);
            ASSERT (myconst.value ().type == &type::named_int);
            ASSERT (myconst.value ().value.int_value == 1);
          }; off();
        }; off();

      }; off();


      scenario(without_type); {

        scenario(not_constant); {
          unit(process_declaration); {
            populate_universe_block (symbol_table);
            EmptyType type (loc);
            Identifier id2 ("new", loc);
            ast::IdentifierExpression idx (loc, id2);
            ast::ExpressionList args (loc);
            Identifier id3 ("int", loc);
            ast::IdentifierType idtype2 (loc, id3);
            ast::TypeExpression tex (loc, &idtype2);
            args.append (&tex);
            ast::Call node (loc, &idx, &args);
            Constant myconst (Identifier ("myconst", loc), &type, &node);
            ASSERT (myconst.process_declaration(er, symbol_table) == false);
            ASSERT (er.list ().size () == 1);
          }; off();
        }; off();

        scenario(sucess); {
          unit(process_declaration); {
            EmptyType type (loc);
            semantic::ExpressionValue val;
            val.kind = semantic::ExpressionValue::Constant;
            val.type = type::UntypedFloat::instance ();
            val.value.untyped_float_value = 37.5;
            Literal expr (loc, val);
            Constant myconst (Identifier ("myconst", loc), &type, &expr);
            ASSERT (myconst.process_declaration(er, symbol_table) == true);
            ASSERT (er.list ().size () == 0);
            ASSERT (myconst.value ().type == type::UntypedFloat::instance ());
            ASSERT (myconst.value ().value.untyped_float_value == 37.5);
          }; off();
        }; off();

      }; off();

    }; off();

  }; off();

  scope(Variable); {
    Variable symbol (Identifier ("name", loc), Immutable, Immutable, &named_int);
    static_cast<Symbol&> (symbol).offset (53);

    unit(Variable); {
      ASSERT (symbol.identifier.identifier () == "name");
      ASSERT (symbol.identifier.location () == loc);
      ASSERT (symbol.type == &named_int);
      ASSERT (symbol.intrinsic_mutability == Immutable);
      ASSERT (symbol.indirection_mutability == Immutable);
    }; off();

    unit(duplicate); {
      Variable* dup = symbol.duplicate ();
      ASSERT (dup->identifier.identifier () == "name");
      ASSERT (dup->identifier.location () == loc);
      ASSERT (dup->type == &named_int);
      ASSERT (dup->intrinsic_mutability == Foreign);
      ASSERT (dup->indirection_mutability == Foreign);
      ASSERT (dup->offset () == 53);
    }; off();

    scenario(SymbolVisitor); {
      unit(accept); {
        TestVisitor<SymbolVisitor, Variable> v;
        symbol.accept (v);
        ASSERT (v.item == &symbol);
        TestDefaultVisitor<SymbolVisitor, Symbol> w;
        symbol.accept (w);
        ASSERT (w.item == &symbol);
      }; off();
    }; off();

    scenario(ConstSymbolVisitor); {
      unit(accept); {
        TestConstVisitor<ConstSymbolVisitor, Variable> cv;
        symbol.accept (cv);
        ASSERT (cv.item == &symbol);
        TestDefaultConstVisitor<ConstSymbolVisitor, Symbol> w;
        symbol.accept (w);
        ASSERT (w.item == &symbol);
      }; off();
    }; off();
  }; off();

  scope(Hidden); {
    Variable var (Identifier ("name", loc), Immutable, Immutable, &named_int);
    Hidden symbol (&var);

    unit(Hidden); {
      ASSERT (symbol.identifier.identifier () == "name");
      ASSERT (symbol.identifier.location () == loc);
    }; off();

    scenario(SymbolVisitor); {
      unit(accept); {
        TestVisitor<SymbolVisitor, Hidden> v;
        symbol.accept (v);
        ASSERT (v.item == &symbol);
        TestDefaultVisitor<SymbolVisitor, Symbol> w;
        symbol.accept (w);
        ASSERT (w.item == &symbol);
      }; off();
    }; off();

    scenario(ConstSymbolVisitor); {
      unit(accept); {
        TestConstVisitor<ConstSymbolVisitor, Hidden> cv;
        symbol.accept (cv);
        ASSERT (cv.item == &symbol);
        TestDefaultConstVisitor<ConstSymbolVisitor, Symbol> w;
        symbol.accept (w);
        ASSERT (w.item == &symbol);
      }; off();
    }; off();

  }; off();

  scope(Field); {
    Struct s;
    source::Package p;
    Field symbol (&s, &p, false, Identifier ("name", loc), &type::named_int, TagSet ());

    unit(Field); {
      ASSERT (symbol.identifier.identifier () == "name");
      ASSERT (symbol.identifier.location () == loc);
      ASSERT (symbol.m_struct == &s);
      ASSERT (symbol.package == &p);
      ASSERT (symbol.is_anonymous == false);
      ASSERT (symbol.type == &type::named_int);
      ASSERT (symbol.tags == TagSet ());
    }; off();

    scenario(SymbolVisitor); {
      unit(accept); {
        TestVisitor<SymbolVisitor, Field> v;
        symbol.accept (v);
        ASSERT (v.item == &symbol);
        TestDefaultVisitor<SymbolVisitor, Symbol> w;
        symbol.accept (w);
        ASSERT (w.item == &symbol);
      }; off();
    }; off();

    scenario(ConstSymbolVisitor); {
      unit(accept); {
        TestConstVisitor<ConstSymbolVisitor, Field> cv;
        symbol.accept (cv);
        ASSERT (cv.item == &symbol);
        TestDefaultConstVisitor<ConstSymbolVisitor, Symbol> w;
        symbol.accept (w);
        ASSERT (w.item == &symbol);
      }; off();
    }; off();

  }; off();

  scope(Symbol); {

    scenario(undefined); {

      unit(process_declaration); {
        EmptyType type (loc);
        Identifier id ("not_defined", loc);
        IdentifierExpression idex (loc, id);
        Constant symbol (Identifier ("name", loc), &type, &idex);
        ASSERT (symbol.process_declaration (er, symbol_table) == false);
        ASSERT (er.list ().size () != 0);
      }; off();

    }; off();

    scenario(recursively_defined); {

      unit(process_declaration); {
        EmptyType type (loc);
        Identifier id ("name", loc);
        IdentifierExpression idex (loc, id);
        Constant symbol (Identifier ("name", loc), &type, &idex);
        symbol_table.enter_symbol (&symbol);
        ASSERT (symbol.process_declaration (er, symbol_table) == false);
        ASSERT (er.list ().size () != 0);
      }; off();

    }; off();

    scenario(still_undefined); {

      unit(process_declaration); {
        EmptyType type (loc);
        Identifier id ("not_defined", loc);
        IdentifierExpression idex (loc, id);
        Constant symbol (Identifier ("name", loc), &type, &idex);
        ASSERT (symbol.process_declaration (er, symbol_table) == false);
        ASSERT (symbol.process_declaration (er, symbol_table) == false);
      }; off();

    }; off();

  }; off();

}; off();
