/* -*- c++ -*- */
#include "unit_test.hpp"
#include "error_reporter.hpp"
#include "scope.hpp"
#include "type.hpp"
#include "astgen.hpp"
#include "symbol_table.hpp"

using namespace semantic;
using namespace util;
using namespace decl;
using namespace type;

scope(semantic); {
  ErrorReporter er;
  SymbolTable symbol_table;
  symbol_table.open_scope ();
  NamedType named_type (DEFAULT_TYPE_NAME, util::Location (), &named_int);

  scenario(type_declared); {
    symbol_table.enter_symbol (&named_type);

    scenario(MethodDecl); {
      unit(enter_method_identifiers); {
        enter_method_identifiers (gen_method_decl ("mymethod"), er, symbol_table);
        ASSERT (named_type.find_method ("mymethod") != NULL);
      }; off();
    }; off();

    scenario(InitDecl); {
      unit(enter_method_identifiers); {
        enter_method_identifiers (gen_init_decl ("myinit"), er, symbol_table);
        ASSERT (named_type.find_initializer ("myinit") != NULL);
      }; off();
    }; off();

    scenario(GetterDecl); {
      unit(enter_method_identifiers); {
        enter_method_identifiers (gen_getter_decl ("mygetter"), er, symbol_table);
        ASSERT (named_type.find_getter ("mygetter") != NULL);
      }; off();
    }; off();

    scenario(ActionDecl); {
      unit(enter_method_identifiers); {
        enter_method_identifiers (gen_action_decl ("myaction"), er, symbol_table);
        ASSERT (named_type.find_action ("myaction") != NULL);
      }; off();
    }; off();

    scenario(ReactionDecl); {
      unit(enter_method_identifiers); {
        enter_method_identifiers (gen_reaction_decl ("myreaction"), er, symbol_table);
        ASSERT (named_type.find_reaction ("myreaction") != NULL);
      }; off();
    }; off();

    scenario(BindDecl); {
      unit(enter_method_identifiers); {
        enter_method_identifiers (gen_bind_decl ("mybind"), er, symbol_table);
        ASSERT (named_type.find_bind ("mybind") != NULL);
      }; off();
    }; off();

    scenario (TopLevelDeclList); {
      unit(enter_method_identifiers); {
        ast::TopLevelDeclList list (1);
        list.append (gen_method_decl ("mymethod"));
        enter_method_identifiers (&list, er, symbol_table);
        ASSERT (named_type.find_method ("mymethod") != NULL);
      }; off();
    }; off();

    scenario (SourceFile); {
      unit(enter_method_identifiers); {
        ast::Identifier package (1, "mypackage");
        ast::TopLevelDeclList list (1);
        list.append (gen_method_decl ("mymethod"));
        ast::SourceFile sf (1, &package, new ast::ImportDeclList (1), &list);
        enter_method_identifiers (&sf, er, symbol_table);
        ASSERT (named_type.find_method ("mymethod") != NULL);
      }; off();
    }; off();

  }; off();

  scenario(type_not_declared); {

    scenario(MethodDecl); {
      unit(enter_method_identifiers); {
        enter_method_identifiers (gen_method_decl ("mymethod"), er, symbol_table);
        ASSERT (named_type.find_method ("mymethod") == NULL);
        ASSERT (er.list ().size () == 1);
      }; off();
    }; off();

    scenario(InitDecl); {
      unit(enter_method_identifiers); {
        enter_method_identifiers (gen_init_decl ("myinit"), er, symbol_table);
        ASSERT (named_type.find_initializer ("myinit") == NULL);
        ASSERT (er.list ().size () == 1);
      }; off();
    }; off();

    scenario(GetterDecl); {
      unit(enter_method_identifiers); {
        enter_method_identifiers (gen_getter_decl ("mygetter"), er, symbol_table);
        ASSERT (named_type.find_getter ("mygetter") == NULL);
        ASSERT (er.list ().size () == 1);
      }; off();
    }; off();

    scenario(ActionDecl); {
      unit(enter_method_identifiers); {
        enter_method_identifiers (gen_action_decl ("myaction"), er, symbol_table);
        ASSERT (named_type.find_action ("myaction") == NULL);
        ASSERT (er.list ().size () == 1);
      }; off();
    }; off();

    scenario(ReactionDecl); {
      unit(enter_method_identifiers); {
        enter_method_identifiers (gen_reaction_decl ("myreaction"), er, symbol_table);
        ASSERT (named_type.find_reaction ("myreaction") == NULL);
        ASSERT (er.list ().size () == 1);
      }; off();
    }; off();

    scenario(BindDecl); {
      unit(enter_method_identifiers); {
        enter_method_identifiers (gen_bind_decl ("mybind"), er, symbol_table);
        ASSERT (named_type.find_bind ("mybind") == NULL);
        ASSERT (er.list ().size () == 1);
      }; off();
    }; off();
  }; off();

  scenario(not_a_type); {
    semantic::ExpressionValue v;
    v.kind = semantic::ExpressionValue::Constant;
    v.type = &named_int;
    v.value.int_value = 5;
    Constant c (DEFAULT_TYPE_NAME, util::Location (), v);
    symbol_table.enter_symbol (&c);

    unit(enter_method_identifiers); {
      enter_method_identifiers (gen_method_decl ("mymethod"), er, symbol_table);
      ASSERT (named_type.find_method ("mymethod") == NULL);
      ASSERT (er.list ().size () == 1);
    }; off();

  }; off();

}; off();
