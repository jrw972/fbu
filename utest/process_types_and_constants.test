/* -*- c++ -*- */
#include "unit_test.hpp"
#include "process_types_and_constants.hpp"
#include "node.hpp"
#include "error_reporter.hpp"
#include "scope.hpp"
#include "enter_predeclared_identifiers.hpp"
#include "type.hpp"
#include "symbol_cast.hpp"

using namespace semantic;

scope(semantic); {
  util::ErrorReporter er;
  decl::Scope scope;
  scenario(Type); {
    unit(process_types_and_constants); {
      ast::Identifier id1 (1, "mytype");
      ast::Identifier id2 (1, "int");
      ast::IdentifierType identifier_type (1, &id2);
      ast::Type root (1, &id1, &identifier_type);
      enter_predeclared_identifiers (&scope);
      process_types_and_constants (&root, er, &scope);
      ASSERT (scope.find_global_symbol ("mytype") != NULL);
    }; off();
  }; off();
  scenario(Const); {
    unit(process_types_and_constants); {
      ast::IdentifierList identifiers (1);
      identifiers.append (new ast::Identifier (1, "x"));
      ast::Identifier id1 (1, "int");
      ast::IdentifierType type (1, &id1);
      semantic::Value sv;
      sv.present = 1;
      sv.untyped_integer_value = 1;
      ast::Literal value (1, type::UntypedInteger::instance (), sv);
      ast::ExpressionList expressions (1);
      expressions.append (&value);
      ast::Const root (1, &identifiers, &type, &expressions);
      enter_predeclared_identifiers (&scope);
      process_types_and_constants (&root, er, &scope);
      ASSERT (root.done);
      decl::Symbol* sym = scope.find_global_symbol ("x");
      ASSERT (sym != NULL);
      decl::Constant* c = decl::symbol_cast<decl::Constant> (sym);
      ASSERT (c != NULL);
      ASSERT (c->type == &type::named_int);
      ASSERT (c->value.present);
      ASSERT (c->value.int_value == 1);
    }; off();
  }; off();
  scenario(Const_Mismatch); {
    unit(process_types_and_constants); {
      ast::IdentifierList identifiers (1);
      identifiers.append (new ast::Identifier (1, "x"));
      ast::Identifier id1 (1, "int");
      ast::IdentifierType type (1, &id1);
      ast::ExpressionList expressions (1);
      ast::Const root (1, &identifiers, &type, &expressions);
      enter_predeclared_identifiers (&scope);
      process_types_and_constants (&root, er, &scope);
      ASSERT (root.done);
      ASSERT (er.count () == 1);
      ASSERT (er.list ().back () == util::Expected_N_Expressions);
    }; off();
  }; off();
  scenario(Const_Not_Const); {
    unit(process_types_and_constants); {
      ast::IdentifierList identifiers (1);
      identifiers.append (new ast::Identifier (1, "x"));
      ast::Identifier id1 (1, "int");
      ast::IdentifierType idtype (1, &id1);
      ast::Pointer type (1, &idtype);
      ast::Identifier id2 (1, "new");
      ast::IdentifierExpression idx (1, &id2);
      ast::ExpressionList args (1);
      ast::Identifier id3 (1, "int");
      ast::IdentifierType idtype2 (1, &id3);
      ast::TypeExpression tex (1, &idtype2);
      args.append (&tex);
      ast::Call call (1, &idx, &args);
      ast::ExpressionList expressions (1);
      expressions.append (&call);
      ast::Const root (1, &identifiers, &type, &expressions);
      enter_predeclared_identifiers (&scope);
      process_types_and_constants (&root, er, &scope);
      ASSERT (root.done);
      ASSERT (er.count () == 1);
      ASSERT (er.list ().back () == util::Expression_Is_Not_Constant);
    }; off();
  }; off();
  scenario(Const_Not_Assignable); {
    unit(process_types_and_constants); {
      ast::IdentifierList identifiers (1);
      identifiers.append (new ast::Identifier (1, "x"));
      ast::Identifier id1 (1, "int");
      ast::IdentifierType type (1, &id1);
      semantic::Value sv;
      sv.present = 1;
      sv.untyped_float_value = 1.5;
      ast::Literal value (1, type::UntypedFloat::instance (), sv);
      ast::ExpressionList expressions (1);
      expressions.append (&value);
      ast::Const root (1, &identifiers, &type, &expressions);
      enter_predeclared_identifiers (&scope);
      process_types_and_constants (&root, er, &scope);
      ASSERT (root.done);
      ASSERT (er.count () == 1);
      ASSERT (er.list ().back () == util::Cannot_Convert);
    }; off();
  }; off();
  scenario(Const_No_Type); {
    unit(process_types_and_constants); {
      ast::IdentifierList identifiers (1);
      identifiers.append (new ast::Identifier (1, "x"));
      ast::EmptyType type (1);
      semantic::Value sv;
      sv.present = 1;
      sv.untyped_integer_value = 1;
      ast::Literal value (1, type::UntypedInteger::instance (), sv);
      ast::ExpressionList expressions (1);
      expressions.append (&value);
      ast::Const root (1, &identifiers, &type, &expressions);
      enter_predeclared_identifiers (&scope);
      process_types_and_constants (&root, er, &scope);
      ASSERT (root.done);
      decl::Symbol* sym = scope.find_global_symbol ("x");
      ASSERT (sym != NULL);
      decl::Constant* c = decl::symbol_cast<decl::Constant> (sym);
      ASSERT (c != NULL);
      ASSERT (c->type == type::UntypedInteger::instance ());
      ASSERT (c->value.present);
      ASSERT (c->value.untyped_integer_value == 1);
    }; off();
  }; off();
  scenario(Const_No_Type_Not_Const); {
    unit(process_types_and_constants); {
      ast::IdentifierList identifiers (1);
      identifiers.append (new ast::Identifier (1, "x"));
      ast::EmptyType type (1);
      ast::Identifier id2 (1, "new");
      ast::IdentifierExpression idx (1, &id2);
      ast::ExpressionList args (1);
      ast::Identifier id3 (1, "int");
      ast::IdentifierType idtype2 (1, &id3);
      ast::TypeExpression tex (1, &idtype2);
      args.append (&tex);
      ast::Call call (1, &idx, &args);
      ast::ExpressionList expressions (1);
      expressions.append (&call);
      ast::Const root (1, &identifiers, &type, &expressions);
      enter_predeclared_identifiers (&scope);
      process_types_and_constants (&root, er, &scope);
      ASSERT (root.done);
      ASSERT (er.count () == 1);
      ASSERT (er.list ().back () == util::Expression_Is_Not_Constant);
    }; off();
  }; off();
}; off();
