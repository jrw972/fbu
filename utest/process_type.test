/* -*- c++ -*- */
#include "unit_test.hpp"
#include "process_type.hpp"
#include "error_reporter.hpp"
#include "scope.hpp"
#include "node.hpp"
#include "type.hpp"
#include "parameter_list.hpp"
#include "symbol_table.hpp"
#include "identifier.hpp"
#include "decl.hpp"

using namespace semantic;
using namespace util;
using namespace decl;
using namespace type;
using namespace ast;
using namespace source;

scope(semantic); {

  ErrorReporter er;
  SymbolTable symbol_table;
  symbol_table.open_scope ();
  Location loc (Location::builtin);

  scenario(not_constant); {
    unit(process_array_dimension); {
      populate_universe_block (symbol_table);
      Identifier id2 ("new", loc);
      ast::IdentifierExpression idx (loc, id2);
      ast::ExpressionList args (loc);
      Identifier id3 ("int", loc);
      ast::IdentifierType idtype2 (loc, id3);
      ast::TypeExpression tex (loc, &idtype2);
      args.append (&tex);
      ast::Call node (loc, &idx, &args);
      long dim = process_array_dimension (er, symbol_table, &node);
      ASSERT (dim == -1);
      ASSERT (er.list ().size () == 1);
    }; off();
  }; off();

  scenario(not_integer); {
    unit(process_array_dimension); {
      semantic::ExpressionValue sv;
      sv.kind = semantic::ExpressionValue::Constant;
      sv.type = type::UntypedString::instance ();
      sv.value.untyped_string_value = runtime::String::make ("not an integer");
      ast::Literal node (loc, sv);
      long dim = process_array_dimension (er, symbol_table, &node);
      ASSERT (dim == -1);
      ASSERT (er.list ().size () == 1);
    }; off();
  }; off();

  scenario(negative); {
    unit(process_array_dimension); {
      semantic::ExpressionValue sv;
      sv.kind = semantic::ExpressionValue::Constant;
      sv.type = type::UntypedInteger::instance ();
      sv.value.untyped_integer_value = -37;
      ast::Literal node (loc, sv);
      long dim = process_array_dimension (er, symbol_table, &node);
      ASSERT (dim == -1);
      ASSERT (er.list ().size () == 1);
    }; off();
  }; off();

  scenario(success); {
    unit(process_array_dimension); {
      semantic::ExpressionValue sv;
      sv.kind = semantic::ExpressionValue::Constant;
      sv.type = type::UntypedInteger::instance ();
      sv.value.untyped_integer_value = 37;
      ast::Literal node (loc, sv);
      long dim = process_array_dimension (er, symbol_table, &node);
      ASSERT (dim == 37);
    }; off();
  }; off();

  unit(check_for_foreign_safe); {
    decl::ParameterList sig (loc);
    sig.append (Parameter::make (Identifier ("there", loc), Immutable, Immutable, &named_int));
    check_for_foreign_safe (er, &sig);
    ASSERT (er.list ().size () == 0);
    sig.append (Parameter::make (Identifier ("there", loc), Immutable, Mutable, named_int.get_pointer ()));
    check_for_foreign_safe (er, &sig);
    ASSERT (er.list ().size () == 1);
  }; off();

  scenario(require_component); {
    unit(process_receiver); {
      populate_universe_block (symbol_table);
      NamedType mytype (Identifier ("mytype", loc), &type::named_int);
      Identifier this_id ("this", loc);
      Identifier type_id ("int", loc);
      ast::Receiver receiver (loc, this_id, Mutable, Mutable, false, type_id);
      process_receiver (er, symbol_table, &mytype, &receiver, true, false);
      ASSERT (er.list ().size () == 2);
    }; off();
  }; off();

  scenario(require_component_pointer); {
    unit(process_receiver); {
      Component comp (NULL, loc);
      NamedType mytype (Identifier ("mytype", loc), &comp);
      Identifier this_id ("this", loc);
      Identifier type_id ("mytype", loc);
      ast::Receiver receiver (loc, this_id, Mutable, Mutable, false, type_id);
      process_receiver (er, symbol_table, &mytype, &receiver, true, false);
      ASSERT (er.list ().size () == 1);
    }; off();
  }; off();

  scenario(require_dereference_immutability); {
    unit(process_receiver); {
      Component comp (NULL, loc);
      NamedType mytype (Identifier ("mytype", loc), &comp);
      symbol_table.enter_symbol (&mytype);
      Identifier this_id ("this", loc);
      Identifier type_id ("mytype", loc);
      ast::Receiver receiver (loc, this_id, Mutable, Mutable, true, type_id);
      process_receiver (er, symbol_table, &mytype, &receiver, true, true);
      ASSERT (er.list ().size () == 1);
    }; off();
  }; off();

  scenario(success_pointer); {
    unit(process_receiver); {
      Component comp (NULL, loc);
      NamedType mytype (Identifier ("mytype", loc), &comp);
      symbol_table.enter_symbol (&mytype);
      Identifier this_id ("this", loc);
      Identifier type_id ("mytype", loc);
      ast::Receiver receiver (loc, this_id, Mutable, Immutable, true, type_id);
      decl::Parameter* parameter = process_receiver (er, symbol_table, &mytype, &receiver, true, true);
      ASSERT (parameter != NULL);
      ASSERT (parameter->identifier.location () == this_id.location ());
      ASSERT (parameter->identifier.identifier () == this_id.identifier ());
      ASSERT (parameter->type == mytype.get_pointer ());
      ASSERT (parameter->intrinsic_mutability == Mutable);
      ASSERT (parameter->indirection_mutability == Immutable);
      ASSERT (er.list ().size () == 0);
    }; off();
  }; off();

  scenario(success_not_pointer); {
    unit(process_receiver); {
      NamedType mytype (Identifier ("mytype", loc), &type::named_int);
      symbol_table.enter_symbol (&mytype);
      Identifier this_id ("this", loc);
      Identifier type_id ("mytype", loc);
      ast::Receiver receiver (loc, this_id, Mutable, Mutable, false, type_id);
      decl::Parameter* parameter = process_receiver (er, symbol_table, &mytype, &receiver, false, false);
      ASSERT (parameter != NULL);
      ASSERT (parameter->identifier.location () == this_id.location ());
      ASSERT (parameter->identifier.identifier () == this_id.identifier ());
      ASSERT (parameter->type == &mytype);
      ASSERT (parameter->intrinsic_mutability == Mutable);
      ASSERT (parameter->indirection_mutability == Mutable);
      ASSERT (er.list ().size () == 0);
    }; off();
  }; off();


  scenario(bad_type); {
    unit(process_parameter_list); {
      Identifier id1 ("x", loc);
      Identifier id2 ("not_declared", loc);
      ast::IdentifierList identifiers (loc);
      identifiers.append (id1);
      ast::IdentifierType type (loc, id2);
      ast::VariableList variable_list (loc, &identifiers, Mutable, Mutable, &type);
      ast::ParameterList parameter_list (loc);
      parameter_list.append (&variable_list);
      const decl::ParameterList* pl = process_parameter_list (er, symbol_table, &parameter_list, false);
      ASSERT (pl != NULL);
      ASSERT (er.list ().size () == 1);
    }; off();
  }; off();

  scenario(success_return); {
    unit(process_parameter_list); {
      populate_universe_block (symbol_table);
      Identifier id1 ("x", loc);
      Identifier id2 ("int", loc);
      ast::IdentifierList identifiers (loc);
      identifiers.append (id1);
      ast::IdentifierType type (loc, id2);
      ast::VariableList variable_list (loc, &identifiers, Mutable, Mutable, &type);
      ast::ParameterList parameter_list (loc);
      parameter_list.append (&variable_list);
      const decl::ParameterList* pl = process_parameter_list (er, symbol_table, &parameter_list, true);
      ASSERT (pl != NULL);
      ASSERT (er.list ().size () == 0);
      ASSERT (pl->size () == 1);
      const decl::Parameter* p = pl->at (0);
      ASSERT (p->type == &type::named_int);
      ASSERT (p->intrinsic_mutability == Mutable);
      ASSERT (p->indirection_mutability == Mutable);
      ASSERT (p->kind == Parameter::Return);
    }; off();
  }; off();

  scenario(success); {
    unit(process_parameter_list); {
      populate_universe_block (symbol_table);
      Identifier id1 ("x", loc);
      Identifier id2 ("int", loc);
      ast::IdentifierList identifiers (loc);
      identifiers.append (id1);
      ast::IdentifierType type (loc, id2);
      ast::VariableList variable_list (loc, &identifiers, Mutable, Mutable, &type);
      ast::ParameterList parameter_list (loc);
      parameter_list.append (&variable_list);
      const decl::ParameterList* pl = process_parameter_list (er, symbol_table, &parameter_list, false);
      ASSERT (pl != NULL);
      ASSERT (er.list ().size () == 0);
      ASSERT (pl->size () == 1);
      const decl::Parameter* p = pl->at (0);
      ASSERT (p->type == &type::named_int);
      ASSERT (p->intrinsic_mutability == Mutable);
      ASSERT (p->indirection_mutability == Mutable);
      ASSERT (p->kind == Parameter::Ordinary);
    }; off();
  }; off();

  scenario(success); {
    unit(process_signature); {
      populate_universe_block (symbol_table);

      Identifier id1 ("x", loc);
      Identifier id2 ("int", loc);
      ast::IdentifierList identifiers (loc);
      identifiers.append (id1);
      ast::IdentifierType type (loc, id2);
      ast::VariableList variable_list (loc, &identifiers, Mutable, Mutable, &type);
      ast::ParameterList parameter_list (loc);
      parameter_list.append (&variable_list);

      Identifier rid1 ("y", loc);
      Identifier rid2 ("int", loc);
      ast::IdentifierList ridentifiers (loc);
      ridentifiers.append (rid1);
      ast::IdentifierType rtype (loc, rid2);
      ast::VariableList return_variable_list (loc, &ridentifiers, Mutable, Mutable, &rtype);
      ast::ParameterList return_parameter_list (loc);
      return_parameter_list.append (&return_variable_list);

      const decl::ParameterList* pl;
      const decl::ParameterList* rpl;
      process_signature (er, symbol_table, &parameter_list, &return_parameter_list, true, pl, rpl);
      ASSERT (er.list ().size () == 0);
      ASSERT (pl != NULL);
      ASSERT (rpl != NULL);
      ASSERT (pl->size () == 1);
      ASSERT (pl->at (0)->kind == Parameter::Ordinary);
      ASSERT (rpl->size () == 1);
      ASSERT (rpl->at (0)->kind == Parameter::Return);
    }; off();
  }; off();

  scenario(duplicate_parameters); {
    unit(check_unique_parameters); {
      decl::ParameterList parameters (loc);
      parameters.append (Parameter::make (Identifier ("x", loc), Mutable, Mutable, &type::named_int));
      parameters.append (Parameter::make (Identifier ("x", loc), Mutable, Mutable, &type::named_int));
      decl::ParameterList return_parameters (loc);
      return_parameters.append (Parameter::make (Identifier ("x", loc), Mutable, Mutable, &type::named_int));
      type::Function func (&parameters, &return_parameters);
      check_unique_parameters (er, &func);
      ASSERT (er.list ().size () == 2);
    }; off();
  }; off();

  scenario(IdentifierType); {

    scenario(not_delcared); {
      unit(process_type); {
        Identifier id ("not_declared", loc);
        IdentifierType type (loc, id);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 1);
        ASSERT (type.eval.kind == ExpressionValue::Error);
      }; off();
    }; off();

    scenario(not_a_type); {
      unit(process_type); {
        populate_universe_block (symbol_table);
        Identifier id ("true", loc);
        IdentifierType type (loc, id);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 1);
        ASSERT (type.eval.kind == ExpressionValue::Error);
      }; off();
    }; off();

    scenario(not_defined); {
      unit(process_type); {
        Identifier id1 ("mytype", loc);
        Identifier id2 ("not_defined", loc);
        ast::IdentifierType identifier_type (loc, id2);
        ast::TypeDecl typedecl (loc, id1, &identifier_type);
        populate_package_block (&typedecl, er, symbol_table);
        Identifier id ("mytype", loc);
        IdentifierType type (loc, id);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 2);
        ASSERT (type.eval.kind == ExpressionValue::Error);
      }; off();
    }; off();

    scenario(success); {
      unit(process_type); {
        populate_universe_block (symbol_table);
        Identifier id ("int", loc);
        IdentifierType type (loc, id);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 0);
        ASSERT (type.eval.kind == ExpressionValue::Type);
        ASSERT (type.eval.type == &named_int);
      }; off();
    }; off();

  }; off();

  scenario(Array); {

    scenario(illegal_dimension); {
      unit(process_type); {
        populate_universe_block (symbol_table);
        semantic::ExpressionValue sv;
        sv.kind = semantic::ExpressionValue::Constant;
        sv.type = type::UntypedInteger::instance ();
        sv.value.untyped_integer_value = -1;
        ast::Literal dim (loc, sv);
        Identifier id ("int", loc);
        IdentifierType base (loc, id);
        ast::Array type (loc, &dim, &base);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 1);
        ASSERT (type.eval.kind == ExpressionValue::Error);
      }; off();
    }; off();

    scenario(bad_base_type); {
      unit(process_type); {
        semantic::ExpressionValue sv;
        sv.kind = semantic::ExpressionValue::Constant;
        sv.type = type::UntypedInteger::instance ();
        sv.value.untyped_integer_value = 1;
        ast::Literal dim (loc, sv);
        Identifier id ("not_declared", loc);
        IdentifierType base (loc, id);
        ast::Array type (loc, &dim, &base);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 1);
        ASSERT (type.eval.kind == ExpressionValue::Error);
      }; off();
    }; off();

    scenario(success); {
      unit(process_type); {
        populate_universe_block (symbol_table);
        semantic::ExpressionValue sv;
        sv.kind = semantic::ExpressionValue::Constant;
        sv.type = type::UntypedInteger::instance ();
        sv.value.untyped_integer_value = 1;
        ast::Literal dim (loc, sv);
        Identifier id ("int", loc);
        IdentifierType base (loc, id);
        ast::Array type (loc, &dim, &base);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 0);
        ASSERT (type.eval.kind == ExpressionValue::Type);
        ASSERT (type.eval.type == named_int.get_array (1));
      }; off();
    }; off();

  }; off();

  scenario(Slice); {

    scenario(bad_base_type); {
      unit(process_type); {
        Identifier id ("not_declared", loc);
        IdentifierType base (loc, id);
        ast::Slice type (loc, &base);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 1);
        ASSERT (type.eval.kind == ExpressionValue::Error);
      }; off();
    }; off();

    scenario(success); {
      unit(process_type); {
        populate_universe_block (symbol_table);
        Identifier id ("int", loc);
        IdentifierType base (loc, id);
        ast::Slice type (loc, &base);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 0);
        ASSERT (type.eval.kind == ExpressionValue::Type);
        ASSERT (type.eval.type == named_int.get_slice ());
      }; off();
    }; off();

  }; off();

  scenario(Pointer); {

    scenario(bad_base_type); {
      unit(process_type); {
        Identifier id ("not_declared", loc);
        IdentifierType base (loc, id);
        ast::Pointer type (loc, &base);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 1);
        ASSERT (type.eval.kind == ExpressionValue::Error);
      }; off();
    }; off();

    scenario(success); {
      unit(process_type); {
        populate_universe_block (symbol_table);
        Identifier id ("int", loc);
        IdentifierType base (loc, id);
        ast::Pointer type (loc, &base);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 0);
        ASSERT (type.eval.kind == ExpressionValue::Type);
        ASSERT (type.eval.type == named_int.get_pointer ());
      }; off();
    }; off();

  }; off();

  scenario(Heap); {

    scenario(bad_base_type); {
      unit(process_type); {
        Identifier id ("not_declared", loc);
        IdentifierType base (loc, id);
        ast::Heap type (loc, &base);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 1);
        ASSERT (type.eval.kind == ExpressionValue::Error);
      }; off();
    }; off();

    scenario(success); {
      unit(process_type); {
        populate_universe_block (symbol_table);
        Identifier id ("int", loc);
        IdentifierType base (loc, id);
        ast::Heap type (loc, &base);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 0);
        ASSERT (type.eval.kind == ExpressionValue::Type);
        ASSERT (type.eval.type == named_int.get_heap ());
      }; off();
    }; off();

  }; off();

  scenario(EmptyType); {

    unit(process_type); {
      ast::EmptyType type (loc);
      process_type (&type, er, symbol_table);
      ASSERT (er.list ().size () == 0);
      ASSERT (type.eval.kind == ExpressionValue::EmptyType);
    }; off();

  }; off();

  scenario(FieldList); {

    scenario(bad_field_type); {
      unit(process_type); {
        Identifier fid ("the_field", loc);
        ast::IdentifierList identifiers (loc);
        identifiers.append (fid);
        Identifier tid ("not_declared", loc);
        IdentifierType vtype (loc, tid);
        ast::VariableList vl (loc, &identifiers, Immutable, Immutable, &vtype);
        ast::FieldList type (loc);
        type.append (&vl);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () != 0);
        ASSERT (type.eval.kind == ExpressionValue::Type);
        const Struct* s = type.eval.type->to_struct ();
        ASSERT (s != NULL);
        ASSERT (s->field_count () == 0);
      }; off();
    }; off();

    scenario(duplicate_field_name); {
      unit(process_type); {
        populate_universe_block (symbol_table);
        Identifier fid ("the_field", loc);
        ast::IdentifierList identifiers (loc);
        identifiers.append (fid);
        identifiers.append (fid);
        Identifier tid ("int", loc);
        IdentifierType vtype (loc, tid);
        ast::VariableList vl (loc, &identifiers, Immutable, Immutable, &vtype);
        ast::FieldList type (loc);
        type.append (&vl);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () != 0);
        ASSERT (type.eval.kind == ExpressionValue::Type);
        const Struct* s = type.eval.type->to_struct ();
        ASSERT (s != NULL);
        ASSERT (s->field_count () == 1);
      }; off();
    }; off();

    scenario(struct_success); {
      unit(process_type); {
        populate_universe_block (symbol_table);
        Identifier fid1 ("the_field", loc);
        Identifier fid2 ("another", loc);
        ast::IdentifierList identifiers (loc);
        identifiers.append (fid1);
        identifiers.append (fid2);
        Identifier tid ("int", loc);
        IdentifierType vtype (loc, tid);
        ast::VariableList vl (loc, &identifiers, Immutable, Immutable, &vtype);
        ast::FieldList type (loc);
        type.append (&vl);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 0);
        ASSERT (type.eval.kind == ExpressionValue::Type);
        const Struct* s = type.eval.type->to_struct ();
        ASSERT (s != NULL);
        ASSERT (s->field_count () == 2);
      }; off();
    }; off();

    scenario(component_success); {
      unit(process_type); {
        populate_universe_block (symbol_table);
        Identifier fid1 ("the_field", loc);
        Identifier fid2 ("another", loc);
        ast::IdentifierList identifiers (loc);
        identifiers.append (fid1);
        identifiers.append (fid2);
        Identifier tid ("int", loc);
        IdentifierType vtype (loc, tid);
        ast::VariableList vl (loc, &identifiers, Immutable, Immutable, &vtype);
        ast::FieldList type (loc);
        type.is_component = true;
        type.append (&vl);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 0);
        ASSERT (type.eval.kind == ExpressionValue::Type);
        const Struct* s = type.eval.type->to_struct ();
        ASSERT (s != NULL);
        ASSERT (s->kind () == Component_Kind);
        ASSERT (s->field_count () == 3);
      }; off();
    }; off();

    scenario(push_port_success); {
      unit(process_type); {
        ast::ParameterList pl (loc);
        ast::PushPort type (loc, &pl);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 0);
        ASSERT (type.eval.kind == ExpressionValue::Type);
        ASSERT (type.eval.type->kind () == Push_Port_Kind);
      }; off();
    }; off();

    scenario(pull_port_success); {
      unit(process_type); {
        ast::ParameterList pl (loc);
        ast::ParameterList rpl (loc);
        ast::PullPort type (loc, &pl, &rpl);
        process_type (&type, er, symbol_table);
        ASSERT (er.list ().size () == 0);
        ASSERT (type.eval.kind == ExpressionValue::Type);
        ASSERT (type.eval.type->kind () == Pull_Port_Kind);
      }; off();
    }; off();

  }; off();

}; off();
