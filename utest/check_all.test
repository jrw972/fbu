/* -*- c++ -*- */
#include "unit_test.hpp"
#include "error_reporter.hpp"
#include "location.hpp"
#include "polymorphic_function.hpp"

using namespace semantic;
using namespace ast;
using namespace util;
using namespace decl;
using namespace type;
using namespace source;

scope(semantic); {
  ErrorReporter er;
  Location loc = Location::builtin;
  semantic::ExpressionValueList args;
  LocationList locs;
  ExpressionValue out;

  scenario(LogicNot); {
    scenario(error); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_error ());
        check_polymorphic_function_call (er, &logic_not, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        check_polymorphic_function_call (er, &logic_not, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(not_boolean); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        check_polymorphic_function_call (er, &logic_not, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_bool));
        check_polymorphic_function_call (er, &logic_not, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_bool, Immutable, Immutable));
        check_polymorphic_function_call (er, &logic_not, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {
      scenario(bool); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_bool (&type::named_bool, false));
          check_polymorphic_function_call (er, &logic_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.bool_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(untyped_boolean); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_boolean (false));
          check_polymorphic_function_call (er, &logic_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();
    }; off();
  }; off();

  scenario(Negate); {
    scenario(error); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_error ());
        check_polymorphic_function_call (er, &negate, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        check_polymorphic_function_call (er, &negate, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(not_arithmetic); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_bool));
        check_polymorphic_function_call (er, &negate, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        check_polymorphic_function_call (er, &negate, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        check_polymorphic_function_call (er, &negate, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint8_value == 219);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint16_value == 65499);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint32_value == 4294967259);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint64_value == 18446744073709551579UL);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int8_value == -37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int16_value == -37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int32_value == -37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int64_value == -37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.float32_value == -37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.float64_value == -37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (1, 2)));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.complex64_value == runtime::Complex64::make (-1, -2));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex128); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (1, 2)));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.complex128_value == runtime::Complex128::make (-1, -2));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint_value == 18446744073709551579UL);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int_value == -37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uintptr_value == 18446744073709551579UL);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.untyped_rune_value == -37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.untyped_integer_value == -37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float (37));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.untyped_float_value == -37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (1, 2)));
          check_polymorphic_function_call (er, &negate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.untyped_complex_value == semantic::UntypedComplex::make (-1, -2));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(Posate); {
    scenario(error); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_error ());
        check_polymorphic_function_call (er, &posate, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        check_polymorphic_function_call (er, &posate, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(not_boolean); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_bool));
        check_polymorphic_function_call (er, &posate, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        check_polymorphic_function_call (er, &posate, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        check_polymorphic_function_call (er, &posate, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint8_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint16_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint32_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint64_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int8_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int16_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int32_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int64_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.float32_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.float64_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (1, 2)));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.complex64_value == runtime::Complex64::make (1, 2));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex128); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (1, 2)));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.complex128_value == runtime::Complex128::make (1, 2));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uintptr_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.untyped_rune_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.untyped_integer_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float (37));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.untyped_float_value == 37);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (1, 2)));
          check_polymorphic_function_call (er, &posate, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.untyped_complex_value == semantic::UntypedComplex::make (1, 2));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(Complement); {
    scenario(error); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_error ());
        check_polymorphic_function_call (er, &complement, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        check_polymorphic_function_call (er, &complement, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(not_boolean); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_bool));
        check_polymorphic_function_call (er, &complement, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        check_polymorphic_function_call (er, &complement, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        check_polymorphic_function_call (er, &complement, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 37));
          check_polymorphic_function_call (er, &complement, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint8_value == 218);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 37));
          check_polymorphic_function_call (er, &complement, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint16_value == 65498);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 37));
          check_polymorphic_function_call (er, &complement, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint32_value == 4294967258);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 37));
          check_polymorphic_function_call (er, &complement, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint64_value == 18446744073709551578UL);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 37));
          check_polymorphic_function_call (er, &complement, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int8_value == -38);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 37));
          check_polymorphic_function_call (er, &complement, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int16_value == -38);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 37));
          check_polymorphic_function_call (er, &complement, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int32_value ==-38);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 37));
          check_polymorphic_function_call (er, &complement, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int64_value == -38);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 37));
          check_polymorphic_function_call (er, &complement, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uint_value == 18446744073709551578UL);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 37));
          check_polymorphic_function_call (er, &complement, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.int_value == -38);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 37));
          check_polymorphic_function_call (er, &complement, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.uintptr_value == 18446744073709551578UL);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (37));
          check_polymorphic_function_call (er, &complement, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.untyped_rune_value == -38);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (37));
          check_polymorphic_function_call (er, &complement, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.value.untyped_integer_value == -38);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(Multiply); {
    scenario(error); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_error ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_error ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::multiply, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::multiply, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::multiply, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::multiply, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_arithmetic); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::multiply, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::multiply, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::multiply, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedRune::instance ());
          ASSERT (out.value.untyped_rune_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedInteger::instance ());
          ASSERT (out.value.untyped_integer_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedFloat::instance ());
          ASSERT (out.value.untyped_float_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedComplex::instance ());
          ASSERT (out.value.untyped_complex_value == semantic::UntypedComplex::make (-5, 10));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint8);
          ASSERT (out.value.uint8_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint16);
          ASSERT (out.value.uint16_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint32);
          ASSERT (out.value.uint32_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint64);
          ASSERT (out.value.uint64_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int8);
          ASSERT (out.value.int8_value == -26);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int16);
          ASSERT (out.value.int16_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int32);
          ASSERT (out.value.int32_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int64);
          ASSERT (out.value.int64_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_float32);
          ASSERT (out.value.float32_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_float64);
          ASSERT (out.value.float64_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_complex64);
          ASSERT (out.value.complex64_value == runtime::Complex64::make (-5, 10));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex128); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_complex128);
          ASSERT (out.value.complex128_value == runtime::Complex128::make (-5, 10));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint);
          ASSERT (out.value.uint_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int);
          ASSERT (out.value.int_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &multiply, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uintptr);
          ASSERT (out.value.uintptr_value == 113 * 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  // TODO:  Test divide by 0.
  scenario(Divide); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::divide, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::divide, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::divide, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_arithmetic); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::divide, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::divide, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::divide, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedRune::instance ());
          ASSERT (out.value.untyped_rune_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedInteger::instance ());
          ASSERT (out.value.untyped_integer_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedFloat::instance ());
          ASSERT (out.value.untyped_float_value == 56.5);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (3, 6)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (1, 2)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedComplex::instance ());
          ASSERT (out.value.untyped_complex_value == semantic::UntypedComplex::make (3, 0));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint8);
          ASSERT (out.value.uint8_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint16);
          ASSERT (out.value.uint16_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint32);
          ASSERT (out.value.uint32_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint64);
          ASSERT (out.value.uint64_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int8);
          ASSERT (out.value.int8_value == -6);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int16);
          ASSERT (out.value.int16_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int32);
          ASSERT (out.value.int32_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int64);
          ASSERT (out.value.int64_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_float32);
          ASSERT (out.value.float32_value == 56.5);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_float64);
          ASSERT (out.value.float64_value == 56.5);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (3, 6)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (1, 2)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_complex64);
          ASSERT (out.value.complex64_value == runtime::Complex64::make (3, 0));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex128); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (3, 6)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (1, 2)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_complex128);
          ASSERT (out.value.complex128_value == runtime::Complex128::make (3, 0));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint);
          ASSERT (out.value.uint_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int);
          ASSERT (out.value.int_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &divide, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uintptr);
          ASSERT (out.value.uintptr_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

    // TODO:  Test modulus by 0.
  scenario(Modulus); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_arithmetic); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedRune::instance ());
          ASSERT (out.value.untyped_rune_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedInteger::instance ());
          ASSERT (out.value.untyped_integer_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint8);
          ASSERT (out.value.uint8_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint16);
          ASSERT (out.value.uint16_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint32);
          ASSERT (out.value.uint32_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint64);
          ASSERT (out.value.uint64_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int8);
          ASSERT (out.value.int8_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int16);
          ASSERT (out.value.int16_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int32);
          ASSERT (out.value.int32_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int64);
          ASSERT (out.value.int64_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint);
          ASSERT (out.value.uint_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int);
          ASSERT (out.value.int_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::modulus, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uintptr);
          ASSERT (out.value.uintptr_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(Add); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(not_arithmetic); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedRune::instance ());
          ASSERT (out.value.untyped_rune_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedInteger::instance ());
          ASSERT (out.value.untyped_integer_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedFloat::instance ());
          ASSERT (out.value.untyped_float_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedComplex::instance ());
          ASSERT (out.value.untyped_complex_value == semantic::UntypedComplex::make (4, 6));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint8);
          ASSERT (out.value.uint8_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint16);
          ASSERT (out.value.uint16_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint32);
          ASSERT (out.value.uint32_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint64);
          ASSERT (out.value.uint64_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int8);
          ASSERT (out.value.int8_value == 11);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int16);
          ASSERT (out.value.int16_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int32);
          ASSERT (out.value.int32_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int64);
          ASSERT (out.value.int64_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_float32);
          ASSERT (out.value.float32_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_float64);
          ASSERT (out.value.float64_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_complex64);
          ASSERT (out.value.complex64_value == runtime::Complex64::make (4, 6));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex128); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_complex128);
          ASSERT (out.value.complex128_value == runtime::Complex128::make (4, 6));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint);
          ASSERT (out.value.uint_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int);
          ASSERT (out.value.int_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::add, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uintptr);
          ASSERT (out.value.uintptr_value == 113 + 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(Subtract); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_arithmetic); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedRune::instance ());
          ASSERT (out.value.untyped_rune_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedInteger::instance ());
          ASSERT (out.value.untyped_integer_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedFloat::instance ());
          ASSERT (out.value.untyped_float_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedComplex::instance ());
          ASSERT (out.value.untyped_complex_value == semantic::UntypedComplex::make (-2, -2));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint8);
          ASSERT (out.value.uint8_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint16);
          ASSERT (out.value.uint16_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint32);
          ASSERT (out.value.uint32_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint64);
          ASSERT (out.value.uint64_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int8);
          ASSERT (out.value.int8_value == 15);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int16);
          ASSERT (out.value.int16_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int32);
          ASSERT (out.value.int32_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int64);
          ASSERT (out.value.int64_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_float32);
          ASSERT (out.value.float32_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_float64);
          ASSERT (out.value.float64_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_complex64);
          ASSERT (out.value.complex64_value == runtime::Complex64::make (-2, -2));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex128); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_complex128);
          ASSERT (out.value.complex128_value == runtime::Complex128::make (-2, -2));
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint);
          ASSERT (out.value.uint_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int);
          ASSERT (out.value.int_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::subtract, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uintptr);
          ASSERT (out.value.uintptr_value == 113 - 2);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(Equal); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_comparable); {
      unit(check_polymorphic_function_call); {
        type::Struct s;
        args.push_back (ExpressionValue::make_variable (&s));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&s));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::Bool::instance ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::Bool::instance ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(nil); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_nil ());
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_nil ());
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(boolean); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_boolean (true));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_boolean (true));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(string_untyped); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_string_untyped (runtime::String::make ("alpha")));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_string_untyped (runtime::String::make ("alpha")));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(bool); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_bool (&type::named_bool, true));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_bool (&type::named_bool, false));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex128); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(string); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("alpha")));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("beta")));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(pointer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_pointer (type::named_int.get_pointer ()));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_pointer (type::named_int.get_pointer ()));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(NotEqual); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_comparable); {
      unit(check_polymorphic_function_call); {
        type::Struct s;
        args.push_back (ExpressionValue::make_variable (&s));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&s));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::Bool::instance ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::Bool::instance ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(nil); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_nil ());
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_nil ());
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(boolean); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_boolean (true));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_boolean (true));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex (semantic::UntypedComplex::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(string_untyped); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_string_untyped (runtime::String::make ("alpha")));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_string_untyped (runtime::String::make ("alpha")));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(bool); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_bool (&type::named_bool, true));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_bool (&type::named_bool, false));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex64 (&type::named_complex64, runtime::Complex64::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(complex128); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (1, 2)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_complex128 (&type::named_complex128, runtime::Complex128::make (3, 4)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(string); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("alpha")));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("beta")));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(pointer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_pointer (type::named_int.get_pointer ()));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_pointer (type::named_int.get_pointer ()));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::not_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(LessThan); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_comparable); {
      unit(check_polymorphic_function_call); {
        type::Struct s;
        args.push_back (ExpressionValue::make_variable (&s));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&s));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::Bool::instance ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::Bool::instance ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(string_untyped); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_string_untyped (runtime::String::make ("alpha")));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_string_untyped (runtime::String::make ("alpha")));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(string); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("alpha")));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("beta")));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(LessEqual); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_comparable); {
      unit(check_polymorphic_function_call); {
        type::Struct s;
        args.push_back (ExpressionValue::make_variable (&s));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&s));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::Bool::instance ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::Bool::instance ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(string_untyped); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_string_untyped (runtime::String::make ("alpha")));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_string_untyped (runtime::String::make ("alpha")));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(string); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("alpha")));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("beta")));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::less_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(MoreThan); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_comparable); {
      unit(check_polymorphic_function_call); {
        type::Struct s;
        args.push_back (ExpressionValue::make_variable (&s));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&s));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::Bool::instance ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::Bool::instance ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(string_untyped); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_string_untyped (runtime::String::make ("alpha")));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_string_untyped (runtime::String::make ("alpha")));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(string); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("alpha")));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("beta")));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_than, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(MoreEqual); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_comparable); {
      unit(check_polymorphic_function_call); {
        type::Struct s;
        args.push_back (ExpressionValue::make_variable (&s));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&s));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::Bool::instance ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::Bool::instance ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(string_untyped); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_string_untyped (runtime::String::make ("alpha")));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_string_untyped (runtime::String::make ("alpha")));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float32 (&type::named_float32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(float64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float64 (&type::named_float64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == true);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(string); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("alpha")));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("beta")));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::more_equal, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedBoolean::instance ());
          ASSERT (out.value.untyped_boolean_value == false);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(BitAnd); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(left_not_numeric); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_boolean (true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(right_not_numeric); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_boolean (true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_arithmetic); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedRune::instance ());
          ASSERT (out.value.untyped_rune_value == 0);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedInteger::instance ());
          ASSERT (out.value.untyped_integer_value == 0);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint8);
          ASSERT (out.value.uint8_value == 0);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint16);
          ASSERT (out.value.uint16_value == 0);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint32);
          ASSERT (out.value.uint32_value == 0);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint64);
          ASSERT (out.value.uint64_value == 0);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int8);
          ASSERT (out.value.int8_value == 12);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int16);
          ASSERT (out.value.int16_value == 0);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int32);
          ASSERT (out.value.int32_value == 0);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int64);
          ASSERT (out.value.int64_value == 0);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint);
          ASSERT (out.value.uint_value == 0);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int);
          ASSERT (out.value.int_value == 0);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uintptr);
          ASSERT (out.value.uintptr_value == 0);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(BitAndNot); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(left_not_numeric); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_boolean (true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(right_not_numeric); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_boolean (true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_arithmetic); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedRune::instance ());
          ASSERT (out.value.untyped_rune_value == 113);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedInteger::instance ());
          ASSERT (out.value.untyped_integer_value == 113);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint8);
          ASSERT (out.value.uint8_value == 113);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint16);
          ASSERT (out.value.uint16_value == 113);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint32);
          ASSERT (out.value.uint32_value == 113);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint64);
          ASSERT (out.value.uint64_value == 113);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int8);
          ASSERT (out.value.int8_value == 1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int16);
          ASSERT (out.value.int16_value == 113);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int32);
          ASSERT (out.value.int32_value == 113);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int64);
          ASSERT (out.value.int64_value == 113);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint);
          ASSERT (out.value.uint_value == 113);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int);
          ASSERT (out.value.int_value == 113);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_and_not, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uintptr);
          ASSERT (out.value.uintptr_value == 113);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(BitOr); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(left_not_numeric); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_boolean (true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(right_not_numeric); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_boolean (true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_arithmetic); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedRune::instance ());
          ASSERT (out.value.untyped_rune_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedInteger::instance ());
          ASSERT (out.value.untyped_integer_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint8);
          ASSERT (out.value.uint8_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint16);
          ASSERT (out.value.uint16_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint32);
          ASSERT (out.value.uint32_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint64);
          ASSERT (out.value.uint64_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int8);
          ASSERT (out.value.int8_value == -1);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int16);
          ASSERT (out.value.int16_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int32);
          ASSERT (out.value.int32_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int64);
          ASSERT (out.value.int64_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint);
          ASSERT (out.value.uint_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int);
          ASSERT (out.value.int_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_or, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uintptr);
          ASSERT (out.value.uintptr_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(BitXor); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(left_not_numeric); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_boolean (true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(right_not_numeric); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_boolean (true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(incompatible_types); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint16 (&named_uint16, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_arithmetic); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedRune::instance ());
          ASSERT (out.value.untyped_rune_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedInteger::instance ());
          ASSERT (out.value.untyped_integer_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint8);
          ASSERT (out.value.uint8_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint16);
          ASSERT (out.value.uint16_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint32);
          ASSERT (out.value.uint32_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint64);
          ASSERT (out.value.uint64_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, -2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int8);
          ASSERT (out.value.int8_value == -13);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int16);
          ASSERT (out.value.int16_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int32);
          ASSERT (out.value.int32_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int64);
          ASSERT (out.value.int64_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint);
          ASSERT (out.value.uint_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_int (&type::named_int, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int);
          ASSERT (out.value.int_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 2));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::bit_xor, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uintptr);
          ASSERT (out.value.uintptr_value == 115);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(LeftShift); {
    scenario(error); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_error ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_error ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(left_not_integral); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_boolean (true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(right_not_integral); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_boolean (true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(right_not_representable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_float (1.5));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_uint));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_uint, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedRune::instance ());
          ASSERT (out.value.untyped_rune_value == 226);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedInteger::instance ());
          ASSERT (out.value.untyped_integer_value == 226);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint8);
          ASSERT (out.value.uint8_value == 226);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint16);
          ASSERT (out.value.uint16_value == 226);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint32);
          ASSERT (out.value.uint32_value == 226);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint64);
          ASSERT (out.value.uint64_value == 226);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int8);
          ASSERT (out.value.int8_value == 26);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int16);
          ASSERT (out.value.int16_value == 226);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int32);
          ASSERT (out.value.int32_value == 226);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int64);
          ASSERT (out.value.int64_value == 226);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint);
          ASSERT (out.value.uint_value == 226);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int);
          ASSERT (out.value.int_value == 226);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::left_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uintptr);
          ASSERT (out.value.uintptr_value == 226);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(RightShift); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(left_not_integral); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_boolean (true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(right_not_integral); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_boolean (true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(right_not_representable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_integer (37));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_float (1.5));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(variable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_variable (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_variable (&type::named_uint));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(value); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_uint, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(constant); {

      scenario(rune); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_rune (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_rune (1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedRune::instance ());
          ASSERT (out.value.untyped_rune_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(integer); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_integer (113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == type::UntypedInteger::instance ());
          ASSERT (out.value.untyped_integer_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint8);
          ASSERT (out.value.uint8_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint16);
          ASSERT (out.value.uint16_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint32);
          ASSERT (out.value.uint32_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint64);
          ASSERT (out.value.uint64_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int8); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int8 (&type::named_int8, 13));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int8);
          ASSERT (out.value.int8_value == 6);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int16); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int16 (&type::named_int16, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint16 (&type::named_uint16, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int16);
          ASSERT (out.value.int16_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int32); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int32 (&type::named_int32, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint32 (&type::named_uint32, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int32);
          ASSERT (out.value.int32_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int64); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int64 (&type::named_int64, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint64 (&type::named_uint64, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int64);
          ASSERT (out.value.int64_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uint); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uint);
          ASSERT (out.value.uint_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(int); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_int (&type::named_int, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uint (&type::named_uint, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_int);
          ASSERT (out.value.int_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(uintptr); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 113));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_uintptr (&type::named_uintptr, 1));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::right_shift, loc, out, args, locs);
          ASSERT (out.is_constant ());
          ASSERT (out.type == &type::named_uintptr);
          ASSERT (out.value.uintptr_value == 56);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();
  }; off();

  scenario(LogicAnd); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(not_boolean); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 1));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 1));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
    const ExpressionValue utrue = ExpressionValue::make_boolean (true);
    const ExpressionValue ufalse = ExpressionValue::make_boolean (false);
    const ExpressionValue ttrue = ExpressionValue::make_bool (&type::named_bool, true);
    const ExpressionValue tfalse = ExpressionValue::make_bool (&type::named_bool, false);
    const ExpressionValue val = ExpressionValue::make_value (&type::named_bool, Immutable, Immutable);
    const ExpressionValue var = ExpressionValue::make_variable (&type::named_bool);

    scenario(utrue_utrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (utrue);
        locs.push_back (loc);
        args.push_back (utrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == type::UntypedBoolean::instance ());
        ASSERT (out.value.untyped_boolean_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(utrue_ufalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (utrue);
        locs.push_back (loc);
        args.push_back (ufalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == type::UntypedBoolean::instance ());
        ASSERT (out.value.untyped_boolean_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(utrue_ttrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (utrue);
        locs.push_back (loc);
        args.push_back (ttrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(utrue_tfalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (utrue);
        locs.push_back (loc);
        args.push_back (tfalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(utrue_val); {
      unit(check_polymorphic_function_call); {
        args.push_back (utrue);
        locs.push_back (loc);
        args.push_back (val);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(utrue_var); {
      unit(check_polymorphic_function_call); {
        args.push_back (utrue);
        locs.push_back (loc);
        args.push_back (var);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ufalse_utrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ufalse);
        locs.push_back (loc);
        args.push_back (utrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == type::UntypedBoolean::instance ());
        ASSERT (out.value.untyped_boolean_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ufalse_ufalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (ufalse);
        locs.push_back (loc);
        args.push_back (ufalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == type::UntypedBoolean::instance ());
        ASSERT (out.value.untyped_boolean_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ufalse_ttrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ufalse);
        locs.push_back (loc);
        args.push_back (ttrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ufalse_tfalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (ufalse);
        locs.push_back (loc);
        args.push_back (tfalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ufalse_val); {
      unit(check_polymorphic_function_call); {
        args.push_back (ufalse);
        locs.push_back (loc);
        args.push_back (val);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ufalse_var); {
      unit(check_polymorphic_function_call); {
        args.push_back (ufalse);
        locs.push_back (loc);
        args.push_back (var);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ttrue_utrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ttrue);
        locs.push_back (loc);
        args.push_back (utrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ttrue_ufalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (ttrue);
        locs.push_back (loc);
        args.push_back (ufalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ttrue_ttrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ttrue);
        locs.push_back (loc);
        args.push_back (ttrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ttrue_tfalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (ttrue);
        locs.push_back (loc);
        args.push_back (tfalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ttrue_val); {
      unit(check_polymorphic_function_call); {
        args.push_back (ttrue);
        locs.push_back (loc);
        args.push_back (val);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ttrue_var); {
      unit(check_polymorphic_function_call); {
        args.push_back (ttrue);
        locs.push_back (loc);
        args.push_back (var);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(tfalse_utrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (tfalse);
        locs.push_back (loc);
        args.push_back (utrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(tfalse_ufalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (tfalse);
        locs.push_back (loc);
        args.push_back (ufalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(tfalse_ttrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (tfalse);
        locs.push_back (loc);
        args.push_back (ttrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(tfalse_tfalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (tfalse);
        locs.push_back (loc);
        args.push_back (tfalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(tfalse_val); {
      unit(check_polymorphic_function_call); {
        args.push_back (tfalse);
        locs.push_back (loc);
        args.push_back (val);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(tfalse_var); {
      unit(check_polymorphic_function_call); {
        args.push_back (tfalse);
        locs.push_back (loc);
        args.push_back (var);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(val_utrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (val);
        locs.push_back (loc);
        args.push_back (utrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(val_ufalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (val);
        locs.push_back (loc);
        args.push_back (ufalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(val_ttrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (val);
        locs.push_back (loc);
        args.push_back (ttrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(val_tfalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (val);
        locs.push_back (loc);
        args.push_back (tfalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(val_val); {
      unit(check_polymorphic_function_call); {
        args.push_back (val);
        locs.push_back (loc);
        args.push_back (val);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(val_var); {
      unit(check_polymorphic_function_call); {
        args.push_back (val);
        locs.push_back (loc);
        args.push_back (var);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(var_utrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (var);
        locs.push_back (loc);
        args.push_back (utrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(var_ufalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (var);
        locs.push_back (loc);
        args.push_back (ufalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(var_ttrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (var);
        locs.push_back (loc);
        args.push_back (ttrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(var_tfalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (var);
        locs.push_back (loc);
        args.push_back (tfalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(var_val); {
      unit(check_polymorphic_function_call); {
        args.push_back (var);
        locs.push_back (loc);
        args.push_back (val);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(var_var); {
      unit(check_polymorphic_function_call); {
        args.push_back (var);
        locs.push_back (loc);
        args.push_back (var);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_and, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();


  }; off();

  scenario(LogicOr); {
    scenario(left_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(right_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_bool (&named_bool, true));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_void ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(not_boolean); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 1));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_uint8 (&named_uint8, 1));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
    const ExpressionValue utrue = ExpressionValue::make_boolean (true);
    const ExpressionValue ufalse = ExpressionValue::make_boolean (false);
    const ExpressionValue ttrue = ExpressionValue::make_bool (&type::named_bool, true);
    const ExpressionValue tfalse = ExpressionValue::make_bool (&type::named_bool, false);
    const ExpressionValue val = ExpressionValue::make_value (&type::named_bool, Immutable, Immutable);
    const ExpressionValue var = ExpressionValue::make_variable (&type::named_bool);

    scenario(utrue_utrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (utrue);
        locs.push_back (loc);
        args.push_back (utrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == type::UntypedBoolean::instance ());
        ASSERT (out.value.untyped_boolean_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(utrue_ufalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (utrue);
        locs.push_back (loc);
        args.push_back (ufalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == type::UntypedBoolean::instance ());
        ASSERT (out.value.untyped_boolean_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(utrue_ttrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (utrue);
        locs.push_back (loc);
        args.push_back (ttrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(utrue_tfalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (utrue);
        locs.push_back (loc);
        args.push_back (tfalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(utrue_val); {
      unit(check_polymorphic_function_call); {
        args.push_back (utrue);
        locs.push_back (loc);
        args.push_back (val);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(utrue_var); {
      unit(check_polymorphic_function_call); {
        args.push_back (utrue);
        locs.push_back (loc);
        args.push_back (var);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ufalse_utrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ufalse);
        locs.push_back (loc);
        args.push_back (utrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == type::UntypedBoolean::instance ());
        ASSERT (out.value.untyped_boolean_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ufalse_ufalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (ufalse);
        locs.push_back (loc);
        args.push_back (ufalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == type::UntypedBoolean::instance ());
        ASSERT (out.value.untyped_boolean_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ufalse_ttrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ufalse);
        locs.push_back (loc);
        args.push_back (ttrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ufalse_tfalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (ufalse);
        locs.push_back (loc);
        args.push_back (tfalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ufalse_val); {
      unit(check_polymorphic_function_call); {
        args.push_back (ufalse);
        locs.push_back (loc);
        args.push_back (val);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ufalse_var); {
      unit(check_polymorphic_function_call); {
        args.push_back (ufalse);
        locs.push_back (loc);
        args.push_back (var);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ttrue_utrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ttrue);
        locs.push_back (loc);
        args.push_back (utrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ttrue_ufalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (ttrue);
        locs.push_back (loc);
        args.push_back (ufalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ttrue_ttrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ttrue);
        locs.push_back (loc);
        args.push_back (ttrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ttrue_tfalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (ttrue);
        locs.push_back (loc);
        args.push_back (tfalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ttrue_val); {
      unit(check_polymorphic_function_call); {
        args.push_back (ttrue);
        locs.push_back (loc);
        args.push_back (val);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(ttrue_var); {
      unit(check_polymorphic_function_call); {
        args.push_back (ttrue);
        locs.push_back (loc);
        args.push_back (var);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(tfalse_utrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (tfalse);
        locs.push_back (loc);
        args.push_back (utrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(tfalse_ufalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (tfalse);
        locs.push_back (loc);
        args.push_back (ufalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(tfalse_ttrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (tfalse);
        locs.push_back (loc);
        args.push_back (ttrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == true);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(tfalse_tfalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (tfalse);
        locs.push_back (loc);
        args.push_back (tfalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_bool);
        ASSERT (out.value.bool_value == false);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(tfalse_val); {
      unit(check_polymorphic_function_call); {
        args.push_back (tfalse);
        locs.push_back (loc);
        args.push_back (val);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(tfalse_var); {
      unit(check_polymorphic_function_call); {
        args.push_back (tfalse);
        locs.push_back (loc);
        args.push_back (var);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(val_utrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (val);
        locs.push_back (loc);
        args.push_back (utrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(val_ufalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (val);
        locs.push_back (loc);
        args.push_back (ufalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(val_ttrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (val);
        locs.push_back (loc);
        args.push_back (ttrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(val_tfalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (val);
        locs.push_back (loc);
        args.push_back (tfalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(val_val); {
      unit(check_polymorphic_function_call); {
        args.push_back (val);
        locs.push_back (loc);
        args.push_back (val);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(val_var); {
      unit(check_polymorphic_function_call); {
        args.push_back (val);
        locs.push_back (loc);
        args.push_back (var);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(var_utrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (var);
        locs.push_back (loc);
        args.push_back (utrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(var_ufalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (var);
        locs.push_back (loc);
        args.push_back (ufalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(var_ttrue); {
      unit(check_polymorphic_function_call); {
        args.push_back (var);
        locs.push_back (loc);
        args.push_back (ttrue);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(var_tfalse); {
      unit(check_polymorphic_function_call); {
        args.push_back (var);
        locs.push_back (loc);
        args.push_back (tfalse);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(var_val); {
      unit(check_polymorphic_function_call); {
        args.push_back (var);
        locs.push_back (loc);
        args.push_back (val);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(var_var); {
      unit(check_polymorphic_function_call); {
        args.push_back (var);
        locs.push_back (loc);
        args.push_back (var);
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::logic_or, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_bool);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();


  }; off();

  scenario(New); {

    scenario(no_arguments); {
      unit(check_polymorphic_function_call); {
        check_polymorphic_function_call (er, &decl::new_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(too_many_arguments); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_type (&type::named_int));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_type (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::new_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::named_int.get_pointer ());
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Mutable);
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(error); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_error ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::new_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(not_a_type); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 3));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::new_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_A_Type);
      }; off();
    }; off();

    scenario(success); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_type (&type::named_int));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::new_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::named_int.get_pointer ());
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Mutable);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

  }; off();

  scenario(Move); {

    scenario(zero_arguments); {
      unit(check_polymorphic_function_call); {
        check_polymorphic_function_call (er, &decl::move_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(two_arguments); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_int.get_heap ()->get_pointer (), Immutable, Foreign));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (type::named_int.get_heap ()->get_pointer (), Immutable, Foreign));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::move_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::named_int.get_heap ()->get_pointer ());
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Mutable);
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(not_movable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 3));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::move_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_type (type::named_uint8.get_heap ()->get_pointer ()));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::move_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(error); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_error ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::move_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(success); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_int.get_heap ()->get_pointer (), Immutable, Foreign));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::move_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::named_int.get_heap ()->get_pointer ());
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Mutable);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

  }; off();

  scenario(Merge); {

    scenario(zero_arguments); {
      unit(check_polymorphic_function_call); {
        check_polymorphic_function_call (er, &decl::merge_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(two_arguments); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_int.get_heap ()->get_pointer (), Immutable, Foreign));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (type::named_int.get_heap ()->get_pointer (), Immutable, Foreign));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::merge_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::named_int.get_pointer ());
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Mutable);
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(not_movable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_uint8 (&type::named_uint8, 3));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::merge_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_type (type::named_uint8.get_heap ()->get_pointer ()));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::merge_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(error); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_error ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::merge_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(success); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_int.get_heap ()->get_pointer (), Immutable, Foreign));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::merge_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::named_int.get_pointer ());
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Mutable);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

  }; off();

  scenario(Len); {

    scenario(zero_arguments); {
      unit(check_polymorphic_function_call); {
        check_polymorphic_function_call (er, &decl::len_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(two_arguments); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("hello")));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("hello")));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::len_func, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_int);
        ASSERT (out.value.int_value == 5);
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(error); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_error ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::len_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_type (type::named_uint8.get_heap ()->get_pointer ()));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::len_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(constant_string); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_string (&type::named_string, runtime::String::make ("hello")));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::len_func, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_int);
        ASSERT (out.value.int_value == 5);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(string); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_string, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::len_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Immutable);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(array); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_int.get_array (5), Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::len_func, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_int);
        ASSERT (out.value.int_value == 5);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(pointer_to_array); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_int.get_array (5)->get_pointer (), Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::len_func, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_int);
        ASSERT (out.value.int_value == 5);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(slice); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_int.get_slice (), Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::len_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Immutable);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(type_with_no_length); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::len_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

  }; off();

  scenario(Cap); {

    scenario(zero_arguments); {
      unit(check_polymorphic_function_call); {
        check_polymorphic_function_call (er, &decl::cap_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(two_arguments); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_int.get_array (5), Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (type::named_int.get_array (5), Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::cap_func, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_int);
        ASSERT (out.value.int_value == 5);
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(error); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_error ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::cap_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_type (type::named_uint8.get_heap ()->get_pointer ()));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::cap_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(array); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_int.get_array (5), Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::cap_func, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_int);
        ASSERT (out.value.int_value == 5);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(pointer_to_array); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_int.get_array (5)->get_pointer (), Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::cap_func, loc, out, args, locs);
        ASSERT (out.is_constant ());
        ASSERT (out.type == &type::named_int);
        ASSERT (out.value.int_value == 5);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(slice); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_int.get_slice (), Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::cap_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == &type::named_int);
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Immutable);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(type_with_no_capacity); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_int, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::cap_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

  }; off();

  scenario(Make); {

    scenario(zero_arguments); {
      unit(check_polymorphic_function_call); {
        check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(error); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_error ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(not_type); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_uint8, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_A_Type);
      }; off();
    }; off();

    scenario(slice_one_arg); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_type (type::named_uint8.get_slice ()));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::named_uint8.get_slice ());
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Mutable);
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(slice_two_arg); {

      scenario(not_rvalue); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::named_uint8.get_slice ()));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_type (&type::named_uint8));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::named_uint8.get_slice ());
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
        }; off();
      }; off();

      scenario(constant_not_integral); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::named_uint8.get_slice ()));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float (3.5));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::named_uint8.get_slice ());
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_LAST_ERROR (er, Cannot_Convert);
        }; off();
      }; off();

      scenario(constant_negative); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::named_uint8.get_slice ()));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (-3));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::named_uint8.get_slice ());
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_LAST_ERROR (er, Negative_Array_Dimension);
        }; off();
      }; off();

      scenario(not_integral); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::named_uint8.get_slice ()));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_value (&type::named_string, Immutable, Immutable));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::named_uint8.get_slice ());
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_LAST_ERROR (er, Non_Integer_Array_Dimension);
        }; off();
      }; off();

      scenario(success); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::named_uint8.get_slice ()));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_value (&type::named_uint8, Immutable, Immutable));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::named_uint8.get_slice ());
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

    }; off();

    scenario(slice_three_arg); {

      scenario(not_rvalue); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::named_uint8.get_slice ()));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_value (&type::named_uint8, Immutable, Immutable));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_type (&type::named_uint8));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::named_uint8.get_slice ());
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
        }; off();
      }; off();

      scenario(constant_not_integral); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::named_uint8.get_slice ()));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_value (&type::named_uint8, Immutable, Immutable));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_float (3.5));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::named_uint8.get_slice ());
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_LAST_ERROR (er, Cannot_Convert);
        }; off();
      }; off();

      scenario(constant_negative); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::named_uint8.get_slice ()));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_value (&type::named_uint8, Immutable, Immutable));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (-3));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::named_uint8.get_slice ());
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_LAST_ERROR (er, Negative_Array_Dimension);
        }; off();
      }; off();

      scenario(not_integral); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::named_uint8.get_slice ()));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_value (&type::named_uint8, Immutable, Immutable));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_value (&type::named_string, Immutable, Immutable));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::named_uint8.get_slice ());
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_LAST_ERROR (er, Non_Integer_Array_Dimension);
        }; off();
      }; off();

      scenario(success); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::named_uint8.get_slice ()));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_value (&type::named_uint8, Immutable, Immutable));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_value (&type::named_uint8, Immutable, Immutable));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::named_uint8.get_slice ());
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(length_exceeds_capacity); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::named_uint8.get_slice ()));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (5));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (3));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::named_uint8.get_slice ());
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_LAST_ERROR (er, Length_Exceeds_Capacity);
        }; off();
      }; off();

    }; off();

    scenario(slice_four_arg); {

      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_type (type::named_uint8.get_slice ()));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_integer (3));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_integer (5));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_integer (5));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::named_uint8.get_slice ());
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Mutable);
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(map); {

      scenario(success); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::Map::make (&named_uint8, &named_uint8)));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::Map::make (&named_uint8, &named_uint8));
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_NO_ERROR (er);
        }; off();
      }; off();

      scenario(bad_capacity); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::Map::make (&named_uint8, &named_uint8)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (-5));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::Map::make (&named_uint8, &named_uint8));
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_LAST_ERROR (er, Negative_Array_Dimension);
        }; off();
      }; off();

      scenario(three_args); {
        unit(check_polymorphic_function_call); {
          args.push_back (ExpressionValue::make_type (type::Map::make (&named_uint8, &named_uint8)));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (3));
          locs.push_back (loc);
          args.push_back (ExpressionValue::make_integer (3));
          locs.push_back (loc);
          check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
          ASSERT (out.is_value ());
          ASSERT (out.type == type::Map::make (&named_uint8, &named_uint8));
          ASSERT (out.intrinsic_mutability == Immutable);
          ASSERT (out.indirection_mutability == Mutable);
          ASSERT_LAST_ERROR (er, Func_Expects_Count);
        }; off();
      }; off();

    }; off();

    scenario(not_makeable); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_type (&named_uint8));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::make_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

  }; off();

  scenario(Append); {

    scenario(zero_arguments); {
      unit(check_polymorphic_function_call); {
        check_polymorphic_function_call (er, &decl::append_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Func_Expects_Count);
      }; off();
    }; off();

    scenario(error); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_error ());
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::append_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_type (&type::named_uint8));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::append_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(not_slice); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (&type::named_uint8, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::append_func, loc, out, args, locs);
        ASSERT (out.is_error ());
        ASSERT_LAST_ERROR (er, Cannot_Be_Applied);
      }; off();
    }; off();

    scenario(same_slice); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_uint8.get_slice (), Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (type::named_uint8.get_slice (), Immutable, Immutable, true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::append_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::named_uint8.get_slice());
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Mutable);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(bytes_and_string); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_byte.get_slice (), Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_string, Immutable, Immutable, true));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::append_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::named_byte.get_slice());
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Mutable);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

    scenario(arg_not_rvalue); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_byte.get_slice (), Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_type (&type::named_byte));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::append_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::named_byte.get_slice());
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Mutable);
        ASSERT_LAST_ERROR (er, Expected_An_Rvalue);
      }; off();
    }; off();

    scenario(arg_wrong_type); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_byte.get_slice (), Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_int32, Immutable, Immutable));
        locs.push_back (loc);
        check_polymorphic_function_call (er, &decl::append_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::named_byte.get_slice());
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Mutable);
        ASSERT_LAST_ERROR (er, Func_Expects_Arg);
      }; off();
    }; off();

    scenario(success); {
      unit(check_polymorphic_function_call); {
        args.push_back (ExpressionValue::make_value (type::named_byte.get_slice (), Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_value (&type::named_byte, Immutable, Immutable));
        locs.push_back (loc);
        args.push_back (ExpressionValue::make_error ());
        locs.push_back (loc);

        check_polymorphic_function_call (er, &decl::append_func, loc, out, args, locs);
        ASSERT (out.is_value ());
        ASSERT (out.type == type::named_byte.get_slice());
        ASSERT (out.intrinsic_mutability == Immutable);
        ASSERT (out.indirection_mutability == Mutable);
        ASSERT_NO_ERROR (er);
      }; off();
    }; off();

  }; off();

}; off();
