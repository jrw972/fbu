/* -*- c++ -*- */
#include "unit_test.hpp"
#include "node.hpp"
#include "error_reporter.hpp"
#include "scope.hpp"
#include "symbol_cast.hpp"
#include "type.hpp"
#include "semantic.hpp"
#include "symbol_table.hpp"

using namespace semantic;

scope(semantic); {

  util::ErrorReporter er;
  decl::SymbolTable symbol_table;
  symbol_table.open_scope ();

  ast::Identifier id1 (1, "mytype");
  ast::Identifier id2 (1, "int");
  ast::IdentifierType identifier_type (1, &id2);
  ast::TypeDecl typedecl (1, &id1, &identifier_type);

  scenario(TypeDecl); {
    unit(enter_identifiers); {
      enter_identifiers (&typedecl, er, symbol_table, true);
      decl::Symbol* s = symbol_table.retrieve_symbol ("mytype");
      ASSERT (s != NULL);
      ASSERT (decl::symbol_cast<type::NamedType> (s) != NULL);
      ASSERT (s->state () == decl::Symbol::Declared);
    }; off();
  }; off();

  scenario(already_declared_in_package_scope); {
    unit(enter_identifiers); {
      enter_identifiers (&typedecl, er, symbol_table, true);
      enter_identifiers (&typedecl, er, symbol_table, true);
      ASSERT (er.list ().size () == 1);
    }; off();
  }; off();

  scenario(already_declared_in_file_scope); {
    unit(enter_identifiers); {
      enter_identifiers (&typedecl, er, symbol_table, true);
      enter_identifiers (&typedecl, er, symbol_table, true);
      ASSERT (er.list ().size () == 1);
    }; off();
  }; off();

  ast::IdentifierList identifiers (1);
  identifiers.append (new ast::Identifier (1, "x"));
  ast::IdentifierType type (1, &id2);
  semantic::ExpressionValue sv;
  sv.kind = semantic::ExpressionValue::Constant;
  sv.type = type::UntypedInteger::instance ();
  sv.value.untyped_integer_value = 1;
  ast::Literal value (1, sv);
  ast::ExpressionList expressions (1);
  expressions.append (&value);
  ast::ConstDecl constdecl (1, &identifiers, &type, &expressions);

  scenario(ConstDecl); {
    unit(enter_identifiers); {
      enter_identifiers (&constdecl, er, symbol_table, true);
      decl::Symbol* s = symbol_table.retrieve_symbol ("x");
      ASSERT (s != NULL);
      ASSERT (decl::symbol_cast<decl::Constant> (s) != NULL);
      ASSERT (s->state () == decl::Symbol::Declared);
    }; off();
  }; off();

  expressions.append (&value);

  scenario(ConstDecl_mismatch); {
    unit(enter_identifiers); {
      enter_identifiers (&constdecl, er, symbol_table, true);
      ASSERT (er.list ().size () == 1);
    }; off();
  }; off();

  ast::Identifier funcid (1, "f");
  ast::ParameterList parameters (1);
  ast::ParameterList return_parameters (1);
  ast::IdentifierList body (1);
  ast::FunctionDecl functiondecl (1, &funcid, &parameters, &return_parameters, &body);

  scenario(FunctionDecl); {
    unit(enter_identifiers); {
      enter_identifiers (&functiondecl, er, symbol_table, true);
      decl::Symbol* s = symbol_table.retrieve_symbol ("f");
      ASSERT (s != NULL);
      ASSERT (decl::symbol_cast<decl::FunctionBase> (s) != NULL);
      ASSERT (s->state () == decl::Symbol::Declared);
    }; off();
  }; off();

  ast::Identifier identifier (1, "i");
  ast::Identifier init (1, "init");
  ast::IdentifierList arguments (1);
  ast::InstanceDecl instancedecl (1, &identifier, &type, &init, &arguments);

  scenario(InstanceDecl); {
    unit(enter_identifiers); {
      enter_identifiers (&instancedecl, er, symbol_table, true);
      decl::Symbol* s = symbol_table.retrieve_symbol ("i");
      ASSERT (s != NULL);
      ASSERT (decl::symbol_cast<decl::Instance> (s) != NULL);
      ASSERT (s->state () == decl::Symbol::Declared);
    }; off();
  }; off();

  ast::TopLevelDeclList decllist (1);
  decllist.append (&typedecl);
  decllist.append (&constdecl);
  decllist.append (&functiondecl);
  decllist.append (&instancedecl);

  scenario(TopLevelDeclList); {
    unit(enter_identifiers); {
      enter_identifiers (&decllist, er, symbol_table, true);
      ASSERT (symbol_table.retrieve_symbol ("mytype") != NULL);
      ASSERT (symbol_table.retrieve_symbol ("x") != NULL);
      ASSERT (symbol_table.retrieve_symbol ("f") != NULL);
      ASSERT (symbol_table.retrieve_symbol ("i") != NULL);
    }; off();
  }; off();

  ast::Identifier package (1, "package");
  ast::ImportDeclList imports (1);
  ast::SourceFile sourcefile (1, &package, &imports, &decllist);

  scenario(SourceFile); {
    unit(enter_identifiers); {
      enter_identifiers (&sourcefile, er, symbol_table, true);
      ASSERT (symbol_table.retrieve_symbol ("mytype") != NULL);
      ASSERT (symbol_table.retrieve_symbol ("x") != NULL);
      ASSERT (symbol_table.retrieve_symbol ("f") != NULL);
      ASSERT (symbol_table.retrieve_symbol ("i") != NULL);
    }; off();
  }; off();

  file_scope->close ();

}; off();
